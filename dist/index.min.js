var Q={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function N(T,O,f){if(O<0||O>31||T>>>O!=0)throw new RangeError("Value out of range");for(let q=O-1;q>=0;q--)f.push(T>>>q&1)}var h=/^[0-9]*$/,u=/^[A-Z0-9 $%*+.\/:-]*$/;var v=new TextEncoder;class P{constructor({mode:T,numChars:O,bitData:f,text:q}){this.mode=T,this.numChars=O,this.bitData=f,this.text=q}getData(){return this.bitData.slice()}}var A={numeric:{modeBits:1,numCharCountBits:(T)=>[10,12,14][Math.floor((T+7)/17)],test(T){return h.test(T)},write(T){let O=[];for(let f=0;f<T.length;){const q=Math.min(T.length-f,3);N(parseInt(T.substr(f,q),10),q*3+1,O),f+=q}return new P({mode:"numeric",numChars:T.length,bitData:O,text:T})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(T)=>[9,11,13][Math.floor((T+7)/17)],test(T){return u.test(T)},write(T){let O=[],f;for(f=0;f+2<=T.length;f+=2){let q="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(f))*45;q+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(f+1)),N(q,11,O)}if(f<T.length)N("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(f)),6,O);return new P({mode:"alpha",numChars:T.length,bitData:O,text:T})}},byte:{modeBits:4,numCharCountBits:(T)=>[8,16,16][Math.floor((T+7)/17)],write(T){let O=v.encode(T),f=[];for(let q of O)N(q,8,f);return new P({mode:"byte",numChars:O.length,bitData:f,text:T})}}};function z(T){if(T<1||T>255)throw new RangeError("Degree out of range");let O=[];for(let q=0;q<T-1;q++)O.push(0);O.push(1);let f=1;for(let q=0;q<T;q++){for(let J=0;J<O.length;J++)if(O[J]=E(O[J],f),J+1<O.length)O[J]^=O[J+1];f=E(f,2)}return O}function B(T,O){let f=O.map((q)=>0);for(let q of T){const J=q^f.shift();f.push(0),O.forEach((F,W)=>f[W]^=E(F,J))}return f}function E(T,O){if(T>>>8!=0||O>>>8!=0)throw new RangeError("Byte out of range");let f=0;for(let q=7;q>=0;q--)f=f<<1^(f>>>7)*285,f^=(O>>>q&1)*T;return f}function k(T,{minVersion:O=1,maxVersion:f=40,minEcl:q="low"}={}){let J=O,F=q,W,Y;for(;J<=f;J++){const I=R(J,F)*8;if(J==O||J==10||J==27)Y=x(T,J);const K=Y.size;if(K<=I){W=K;break}}if(!W)throw Error("Data too long");let $=["low","medium","quartile","high"],H=$.slice($.indexOf(q)+1);for(let I of H)if(W<=R(J,I)*8)F=I;else break;return{version:J,ecl:F,bitstring:y(T,Y.steps,J,F)}}function x(T,O=1){const f={byte:(4+A.byte.numCharCountBits(O))*6,alpha:(4+A.alpha.numCharCountBits(O))*6,numeric:(4+A.numeric.numCharCountBits(O))*6};let q=[],J=Array.from(T).map((F,W)=>{let Y={byte:b(T.codePointAt(W))*8*6};if(A.alpha.test(F))Y.alpha=33;if(A.numeric.test(F))Y.numeric=20;return Y});Object.keys(J[0]).forEach((F)=>{q.push({size:f[F]+J[0][F],steps:[F]})});for(let F=1;F<J.length;F++){let W=J[F],Y=[],$=Infinity;for(let H=0;H<q.length;H++){let I=q[H];Object.keys(W).forEach((K)=>{let D=K=="byte"?Array(W[K]/48).fill(K):[K],X=I.steps[I.steps.length-1]==K?W[K]+I.size:f[K]+Math.floor((I.size+5)/6)*6+W[K];$=Math.min($,X),Y.push({size:X,steps:[...I.steps,...D]})})}q=Y.filter((H)=>H.size<=$+[14,20,20][Math.floor((O+7)/17)]*6)}return q.sort((F,W)=>F.size-W.size),q=q.map((F)=>({steps:F.steps,size:Math.ceil(F.size/6)})),q[0]}var y=function(T,O,f,q){let J=_(T,O),F=[];for(let Z of J){N(A[Z.mode].modeBits,4,F),N(Z.numChars,A[Z.mode].numCharCountBits(f),F);for(let L of Z.getData())F.push(L)}const W=R(f,q)*8;N(0,Math.min(4,W-F.length),F),N(0,(8-F.length%8)%8,F);for(let Z=236;F.length<W;Z^=236^17)N(Z,8,F);let Y=[];while(Y.length*8<F.length)Y.push(0);F.forEach((Z,L)=>Y[L>>>3]|=Z<<7-(L&7));const $=Q[q].num_ecc_blocks[f],H=Q[q].codewords_per_block[f],I=Math.floor(w(f)/8),K=$-I%$,D=Math.floor(I/$);let X=[];const G=z(H);for(let Z=0,L=0;Z<$;Z++){let M=Y.slice(L,L+D-H+(Z<K?0:1));L+=M.length;const j=B(M,G);if(Z<K)M.push(0);X.push(M.concat(j))}let V=[];for(let Z=0;Z<X[0].length;Z++)X.forEach((L,M)=>{if(Z!=D-H||M>=K)V.push(L[Z])});return V.map((Z)=>Z.toString(2).padStart(8,"0")).join("")},b=function(T=128){if(T<0)throw"invalid";else if(T<128)return 1;else if(T<2048)return 2;else if(T<65536)return 3;else if(T<1114112)return 4;else throw"invalid"},w=function(T){let O=(16*T+128)*T+64;if(T>=2){const f=Math.floor(T/7)+2;O-=(25*f-10)*f-55,O-=T>=7?36:0}return O},R=function(T,O){return Math.floor(w(T)/8)-Q[O].codewords_per_block[T]*Q[O].num_ecc_blocks[T]};function _(T="",O=[]){let f=[],q=O[0],J=0;for(let F=1;F<=T.length;F++)if(F>=T.length||O[F]!=q){let W=T.slice(J,F);f.push(A[q].write(W)),q=O[F],J=F}return f}class U{constructor(T,O){this.arr=new Uint8Array(T*O),this.used=new Uint8Array(T*O),this.w=T,this.h=O}setPixel(T,O,f){let{w:q,h:J}=this;if(T<0||T>=q||O<0||O>=J)return;this.arr[O*q+T]=f&1,this.used[O*q+T]=1}getPixel(T,O){let{w:f,h:q}=this;if(T<0||T>=f||O<0||O>=q)return 0;return this.arr[O*f+T]}usedPixel(T,O){let{w:f,h:q}=this;if(T<0||T>=f||O<0||O>=q)return 0;return this.used[O*f+T]}static combine(...T){let O=Math.max(...T.map((J)=>J.w)),f=Math.max(...T.map((J)=>J.h)),q=new U(O,f);for(let J=0;J<O;J++)for(let F=0;F<f;F++)if(T.some((W)=>W.usedPixel(J,F)))q.setPixel(J,F,T.some((W)=>W.getPixel(J,F)));return q}}var g=[(T,O)=>(T+O)%2==0,(T,O)=>O%2==0,(T,O)=>T%3==0,(T,O)=>(T+O)%3==0,(T,O)=>(Math.floor(T/3)+Math.floor(O/2))%2==0,(T,O)=>T*O%2+T*O%3==0,(T,O)=>(T*O%2+T*O%3)%2==0,(T,O)=>((T+O)%2+T*O%3)%2==0];class S{constructor({version:T=2,ecl:O=0,mask:f=0,bitstring:q="",data:J}={}){this.version=T,this.ecl=O,this.mask=f,this.bitstring=q,this.data=J}get size(){return this.version*4+17}get functional_patterns(){let{finder_patterns:T,timing_patterns:O,alignment_patterns:f,version_pattern:q,format_pattern:J}=this;return U.combine(T,O,f,q,J)}get finder_patterns(){let{size:T}=this,O=new U(T,T);for(let f=0;f<8;f++)for(let q=0;q<8;q++){let J=Math.max(Math.abs(3-f),Math.abs(3-q))!=2&&!(f==7||q==7);O.setPixel(f,q,J),O.setPixel(T-f-1,q,J),O.setPixel(f,T-q-1,J)}return O}get timing_patterns(){let{size:T}=this,O=new U(T,T);for(let f=8;f<=T-8;f++){let q=f%2==0;O.setPixel(6,f,q),O.setPixel(f,6,q)}return O}get alignment_positions(){let{version:T,size:O}=this;if(T==1)return[];const f=Math.floor(T/7)+2,q=T==32?26:Math.ceil((T*4+4)/(f*2-2))*2;let J=[6];for(let F=O-7;J.length<f;F-=q)J.splice(1,0,F);return J}get alignment_patterns(){let{version:T,size:O,alignment_positions:f}=this,q=new U(O,O);const J=f.length;for(let F=0;F<J;F++)for(let W=0;W<J;W++)if(!(F==0&&W==0||F==0&&W==J-1||F==J-1&&W==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let H=Math.max(Math.abs($),Math.abs(Y))==1?0:1;q.setPixel(f[F]+$,f[W]+Y,H)}return q}get format_pattern(){let{ecl:T,mask:O,size:f}=this,q=new U(f,f);const J=Q[T].formatBits<<3|O;let F=J;for(let Y=0;Y<10;Y++)F=F<<1^(F>>>9)*1335;const W=(J<<10|F)^21522;for(let Y=0;Y<=5;Y++)q.setPixel(8,Y,W>>Y);q.setPixel(8,7,W>>6),q.setPixel(8,8,W>>7),q.setPixel(7,8,W>>8);for(let Y=9;Y<15;Y++)q.setPixel(14-Y,8,W>>Y);for(let Y=0;Y<8;Y++)q.setPixel(this.size-1-Y,8,W>>Y);for(let Y=8;Y<15;Y++)q.setPixel(8,this.size-15+Y,W>>Y);return q.setPixel(8,this.size-8,1),q}get version_pattern(){let{version:T,size:O}=this;const f=new U(O,O);if(T<7)return f;let q=T;for(let F=0;F<12;F++)q=q<<1^(q>>>11)*7973;const J=T<<12|q;for(let F=0;F<18;F++){const W=O-11+F%3,Y=Math.floor(F/3);f.setPixel(W,Y,J>>F),f.setPixel(Y,W,J>>F)}return f}get data_pattern(){let{size:T,functional_patterns:O,bitstring:f,mask:q}=this;const J=new U(T,T);let F=0;for(let W=T-1;W>=1;W-=2){if(W==6)W=5;for(let Y=0;Y<T;Y++)for(let $=0;$<2;$++){const H=W-$,K=(W+1&2)==0?T-1-Y:Y;if(!O.usedPixel(H,K)&&F<f.length){let X=parseInt(f[F]);X^=g[q](H,K),J.setPixel(H,K,X),F++}}}return J}get grid(){let{functional_patterns:T,data_pattern:O}=this;return U.combine(T,O)}}function c(T="",O=""){let f=["T:WPA",`S:${T}`,`P:${O}`];return[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,1,0],[2,0,1]].map((q)=>`WIFI:${q.map((J)=>f[J]).join(";")};;`)}function m(T="m4r.sh/tetris",{protocols:O=["http","https"],protocol_caps:f=!0,domain_caps:q=!0,path_caps:J=!1}={}){if(!T.toLowerCase().startsWith("http"))T="http://"+T;let F=new URL(T),{hostname:W,pathname:Y,search:$,hash:H}=F,I=l({protocols:O,protocol_caps:f}),K=p({domain:W,domain_caps:q}),D=n({path:Y,path_caps:J}),X=[];return I.forEach((G)=>{K.forEach((V)=>{D.forEach((Z)=>{X.push(`${G}://${V}${Z}${$}${H}`)})})}),X}var l=function({protocols:T=["HTTP","HTTPS"],protocol_caps:O=!0}={}){let f=[];return T.forEach((q)=>{f.push(...O?C(q):[q])}),f},p=function({domain:T="M4R.SH",domain_caps:O=!0}={}){return O?C(T):[T]},n=function({path:T="/qr/tetris",path_caps:O=!1}={}){return O?C(T):[T]},C=function(T="tEsT"){let O=T.toLowerCase().split(""),f={};for(var q=0,J=1<<T.length;q<J;q++){for(var F=q,W=0;F;F>>=1,W++)O[W]=F&1?O[W].toUpperCase():O[W].toLowerCase();f[O.join("")]=!0}return Object.keys(f)};var Z1=function(T,{minVersion:O=1,maxVersion:f=40,minEcl:q="low",mask:J=0}={}){let{version:F,ecl:W,bitstring:Y}=k(T,{minVersion:O,minEcl:q,maxVersion:f});return new S({data:T,version:F,ecl:W,mask:J,bitstring:Y})};export{c as permuteWIFI,m as permuteURL,k as findVersion,Z1 as createQR,S as QRCode,U as PixelGrid};
