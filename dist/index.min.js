var R=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var b=/^[0-9]*$/,l=/^[A-Z0-9 $%*+.\/:-]*$/;var m=new TextEncoder,M={numeric:{modeBits:1,charCost:(f)=>b.test(f)?3.3333333333333335:1/0,numCharCountBits:(f)=>[10,12,14][Math.floor((f+7)/17)],write(f){let K=[];for(let H=0;H<f.length;){let J=Math.min(f.length-H,3);A(parseInt(f.substr(H,J),10),J*3+1,K),H+=J}return K.slice()}},alpha:{modeBits:2,charCost:(f)=>l.test(f)?5.5:1/0,numCharCountBits:(f)=>[9,11,13][Math.floor((f+7)/17)],write(f){let K=[],H;for(H=0;H+2<=f.length;H+=2){let J="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H))*45;J+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H+1)),A(J,11,K)}if(H<f.length)A("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H)),6,K);return K.slice()}},byte:{modeBits:4,charCost:(f)=>g(f)*8,numCharCountBits:(f)=>[8,16,16][Math.floor((f+7)/17)],test:(f)=>!0,write(f){let K=m.encode(f),H=[];for(let J of K)A(J,8,H);return H.slice()}}};function A(f,K,H){while(K>31)A(f>>>K-31,31,H),K-=31;if(f>>>K!==0)throw new RangeError("Value out of range");for(let J=K-1;J>=0;J--)H.push(f>>>J&1)}function g(f){let K=f.codePointAt(0);if(K<0)throw"invalid";else if(K<128)return 1;else if(K<2048)return 2;else if(K<65536)return 3;else if(K<1114112)return 4;else throw"invalid"}function u(f){if(f<1||f>255)throw new RangeError("Degree out of range");let K=[];for(let J=0;J<f-1;J++)K.push(0);K.push(1);let H=1;for(let J=0;J<f;J++){for(let Y=0;Y<K.length;Y++)if(K[Y]=B(K[Y],H),Y+1<K.length)K[Y]^=K[Y+1];H=B(H,2)}return K}function w(f,K){let H=K.map((J)=>0);for(let J of f){let Y=J^H.shift();H.push(0),K.forEach((W,$)=>H[$]^=B(W,Y))}return H}function B(f,K){if(f>>>8!=0||K>>>8!=0)throw new RangeError("Byte out of range");let H=0;for(let J=7;J>=0;J--)H=H<<1^(H>>>7)*285,H^=(K>>>J&1)*f;return H}function k(f,{minVersion:K=1,maxVersion:H=40,minEcl:J=0,maxEcl:Y=3}={}){let W=K,$=J,Z;if(M.numeric.charCost("1")*f.length>L(H,$)*8)throw new Error("Data too long");for(;W<=H;W++){let T=L(W,$)*8;if(W==K||W==10||W==27)Z=t(f,W);if(Z&&Z.cost<=T)break}if(!Z||Z.cost>L(W,$)*8||W>H)throw new Error("Data too long");for(let T=$+1;T<=Y;T++)if(Z.cost<=L(W,T)*8)$=T;else break;return{version:W,ecl:$,codewords:C(f,Z.steps,W,$),cost:Z.cost,steps:Z.steps,strategy:o(Z.steps),budget:L(W,$)*8}}function o(f){let K=f.map((Y)=>["byte","numeric","alpha","kanji"].indexOf(Y)),H=Math.ceil(K.length/4),J=new Uint8Array(H);for(let Y=0;Y<K.length;Y++){let W=Math.floor(Y/4),$=(3-Y%4)*2;J[W]|=(K[Y]&3)<<$}return J}function n(f,K,H){let J=L(K,H)*8,Y=f.length,W=[new V];for(let $=0;$<Y;$++){let Z=[];for(let T of W)for(let U of["numeric","alpha","byte"]){let q=M[U].charCost(f[$]);if(q===1/0)continue;let P=T.lastMode===U?0:4+M[U].numCharCountBits(K),Q=T.cost+P+q;if(T.lastMode!=U)Q=Math.ceil(Q);if(Q>J-(Y-1-$)*3.3333333333333335)continue;Z.push(T.addStep(U,Q))}W=Z}return W}function t(f,K){let H=f.length,J=Array(H+1).fill().map(()=>({}));J[0][""]=new V;for(let $=1;$<=H;$++)for(let Z in J[$-1]){let T=J[$-1][Z];for(let U of["numeric","alpha","byte"]){let q=M[U].charCost(f[$-1]);if(q===1/0)continue;let P=T.lastMode===U?0:4+M[U].numCharCountBits(K),Q=T.cost+P+q;if(T.lastMode!==U)Q=Math.ceil(Q);let F=T.addStep(U,Q),_=J[$][U];if(!_||F.cost<_.cost)J[$][U]=F}}let Y=J[H],W=null;for(let $ in Y)if(!W||Y[$].cost<W.cost)W=Y[$];return W?{steps:W.getSteps(),cost:W.cost}:null}function C(f,K,H,J){let Y=a(f,K),W=[];for(let{mode:O,str:I}of Y){A(M[O].modeBits,4,W),A(I.length,M[O].numCharCountBits(H),W);for(let h of M[O].write(I))W.push(h)}let $=L(H,J)*8;A(0,Math.min(4,$-W.length),W),A(0,(8-W.length%8)%8,W);for(let O=236;W.length<$;O^=253)A(O,8,W);let Z=[];while(Z.length*8<W.length)Z.push(0);W.forEach((O,I)=>Z[I>>>3]|=O<<7-(I&7));let T=R[J].num_ecc_blocks[H],U=R[J].codewords_per_block[H],q=Math.floor(y(H)/8),P=T-q%T,Q=Math.floor(q/T),F=[],_=u(U);for(let O=0,I=0;O<T;O++){let h=Z.slice(I,I+Q-U+(O<P?0:1));I+=h.length;let v=w(h,_);if(O<P)h.push(0);F.push(h.concat(v))}let N=[];for(let O=0;O<F[0].length;O++)F.forEach((I,h)=>{if(O!=Q-U||h>=P)N.push(I[O])});return new Uint8Array(N)}function y(f){let K=(16*f+128)*f+64;if(f>=2){let H=Math.floor(f/7)+2;K-=(25*H-10)*H-55,K-=f>=7?36:0}return K}function L(f,K){return Math.floor(y(f)/8)-R[K].codewords_per_block[f]*R[K].num_ecc_blocks[f]}function a(f="",K=[]){let H=[],J=K[0],Y=0;for(let W=1;W<=f.length;W++)if(W>=f.length||K[W]!=J)H.push({mode:J,str:f.slice(Y,W)}),J=K[W],Y=W;return H}var s=["byte","numeric","alpha","kanji"],d={byte:0,numeric:1,alpha:2,kanji:3};class V{constructor(f=new Uint8Array(0),K=0,H=0,J=""){this.packed=f,this.length=K,this.cost=H,this.lastMode=J}addStep(f,K){let{length:H,packed:J}=this,Y=Math.floor(H/4),W=(3-H%4)*2,$=J.length+(Y<J.length?0:1),Z=new Uint8Array($);return Z.set(J),Z[Y]|=d[f]<<W,new V(Z,H+1,K,f)}getSteps(){return Array.from({length:this.length},(f,K)=>{let H=this.packed[Math.floor(K/4)],J=(3-K%4)*2;return s[H>>J&3]})}}var{floor:c}=Math,D=[(f,K)=>(f+K)%2==0,(f,K)=>K%2==0,(f,K)=>f%3==0,(f,K)=>(f+K)%3==0,(f,K)=>(c(f/3)+c(K/2))%2==0,(f,K)=>f*K%2+f*K%3==0,(f,K)=>(f*K%2+f*K%3)%2==0,(f,K)=>((f+K)%2+f*K%3)%2==0];class X{constructor(f,K){this.w=f,this.h=K;let J=f*K+31>>5;this.valueBits=new Uint32Array(J),this.usedBits=new Uint32Array(J)}#f(f,K){let H=K*this.w+f;return[H>>5,H&31]}set(f=0,K=0,H=1){if(f<0||f>=this.w||K<0||K>=this.h)return;let[J,Y]=this.#f(f,K),W=1<<Y;if(H&1)this.valueBits[J]|=W;else this.valueBits[J]&=~W;this.usedBits[J]|=W}get(f=0,K=0){if(f<0||f>=this.w||K<0||K>=this.h)return 0;let[H,J]=this.#f(f,K),Y=1<<J;return this.valueBits[H]&Y?1:0}used(f=0,K=0){if(f<0||f>=this.w||K<0||K>=this.h)return 0;let[H,J]=this.#f(f,K),Y=1<<J;return this.usedBits[H]&Y?1:0}*tiles(f=null){let{w:K,h:H,usedBits:J,valueBits:Y}=this,W=K*H,$=J.length;for(let Z=0;Z<$;Z++){let T=J[Z];if(T===0)continue;let U=Y[Z],q=Z<<5;for(let P=0;P<32;P++){let Q=q+P;if(Q>=W)break;let F=1<<P;if(!(T&F))continue;let _=(U&F)!==0;if(f==null||!f==!_)yield[Q%K,Math.floor(Q/K)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let K=Math.max(...f.map((Y)=>Y.w)),H=Math.max(...f.map((Y)=>Y.h)),J=new X(K,H);for(let Y of f)for(let[W,$]of Y.tiles())if(!J.get(W,$))J.set(W,$,Y.get(W,$));return J}static erase(f,...K){let H=new X(f.w,f.h);for(let[J,Y]of f.tiles())if(!K.some((W)=>W.used(J,Y)))H.set(J,Y,f.get(J,Y));return H}static intersect(f,...K){let H=new X(f.w,f.h);for(let[J,Y]of f.tiles())if(K.every((W)=>W.used(J,Y)))H.set(J,Y,f.get(J,Y));return H}static invert(f){let K=new X(f.w,f.h);for(let[H,J]of f.tiles())K.set(H,J,!f.get(H,J));return K}}class G{constructor({version:f=2,ecl:K=0,mask:H=0,codewords:J=new Uint8Array}={}){this.version=f,this.ecl=K,this.mask=H,this.codewords=J}get size(){return this.version*4+17}get functional_grid(){let f=new X(this.size,this.size);return j(f,this),z(f,this),x(f,this),S(f,this),f}get finder_grid(){let f=new X(this.size,this.size);return j(f,this),f}get timing_grid(){let f=new X(this.size,this.size);return z(f,this),f}get alignment_grid(){let f=new X(this.size,this.size);return x(f,this),f}get format_grid(){let f=new X(this.size,this.size);return p(f,this),f}get version_grid(){let f=new X(this.size,this.size);return S(f,this),f}get data_grid(){let f=new X(this.size,this.size);return E(f,this,this.functional_grid),f}get rawdata_grid(){let f=new X(this.size,this.size);return E(f,this,this.functional_grid,!0),f}get grid(){let f=new X(this.size,this.size);return j(f,this),z(f,this),x(f,this),S(f,this),E(f,this),f}toBytes(){return new Uint8Array([this.version&255,(this.ecl&3)<<3|(this.mask&7)<<5,...this.codewords])}toString(){let f=this.toBytes(),K="";return f.forEach((H)=>K+=String.fromCharCode(H)),btoa(K)}static fromBytes(f){return new G({version:f[0],ecl:f[1]>>3&3,mask:f[1]>>5&7,codewords:f.slice(2)})}static fromString(f){return G.fromBytes(Uint8Array.from(atob(f),(K)=>K.charCodeAt(0)))}}function E(f,K,H,J=!1){if(!H)H=f;let{codewords:Y,mask:W,size:$}=K;p(f,K);let Z=0;for(let T=$-1;T>=1;T-=2){if(T===6)T=5;for(let U=0;U<$;U++)for(let q=0;q<2;q++){let P=T-q,F=(T+1&2)===0?$-1-U:U;if(!H.used(P,F)){let N=0;if(Z<Y.length*8){let O=Math.floor(Z/8),I=7-Z%8;N=Y[O]>>I&1}if(J!==!0)N^=D[W](P,F);f.set(P,F,N),Z++}}}}function j(f,{size:K}){for(let H=0;H<8;H++)for(let J=0;J<8;J++){let Y=Math.max(Math.abs(3-H),Math.abs(3-J))!=2&&!(H==7||J==7);f.set(H,J,Y),f.set(K-H-1,J,Y),f.set(H,K-J-1,Y)}}function z(f,{size:K}){for(let H=8;H<=K-8;H++){let J=H%2==0;f.set(6,H,J),f.set(H,6,J)}}function x(f,{size:K,version:H}){let J=r(H,K),Y=J.length;for(let W=0;W<Y;W++)for(let $=0;$<Y;$++)if(!(W==0&&$==0||W==0&&$==Y-1||W==Y-1&&$==0))for(let Z=-2;Z<=2;Z++)for(let T=-2;T<=2;T++){let U=Math.max(Math.abs(T),Math.abs(Z))==1?0:1;f.set(J[W]+T,J[$]+Z,U)}}function p(f,{ecl:K,mask:H,size:J}){let Y=R[K].formatBits<<3|H,W=Y;for(let Z=0;Z<10;Z++)W=W<<1^(W>>>9)*1335;let $=(Y<<10|W)^21522;for(let Z=0;Z<=5;Z++)f.set(8,Z,$>>Z);f.set(8,7,$>>6),f.set(8,8,$>>7),f.set(7,8,$>>8);for(let Z=9;Z<15;Z++)f.set(14-Z,8,$>>Z);for(let Z=0;Z<8;Z++)f.set(J-1-Z,8,$>>Z);for(let Z=8;Z<15;Z++)f.set(8,J-15+Z,$>>Z);f.set(8,J-8,1)}function S(f,{version:K,size:H}){if(K<7)return;let J=K;for(let W=0;W<12;W++)J=J<<1^(J>>>11)*7973;let Y=K<<12|J;for(let W=0;W<18;W++){let $=H-11+W%3,Z=Math.floor(W/3);f.set($,Z,Y>>W),f.set(Z,$,Y>>W)}}function r(f,K){if(f==1)return[];let H=Math.floor(f/7)+2,J=f==32?26:Math.ceil((f*4+4)/(H*2-2))*2,Y=[6];for(let W=K-7;Y.length<H;W-=J)Y.splice(1,0,W);return Y}function I2(f="",{minVersion:K=1,maxVersion:H=40,minEcl:J=0,maxEcl:Y=3,ecl:W=null,version:$=null,mask:Z=0}={}){if($)K=H=$;if(W)J=Y=W;let T=k(f,{minVersion:K,minEcl:J,maxEcl:Y,maxVersion:H});return new G({mask:Z,version:T.version,ecl:T.ecl,codewords:T.codewords})}export{k as optimalStrategy,I2 as createQR,C as constructCodewords,n as allStrategies,G as QRCode,D as MASK_SHAPES,X as Grid,R as ECLS};
