var D={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function X(O,q,F){if(q<0||q>31||O>>>q!=0)throw new RangeError("Value out of range");for(let J=q-1;J>=0;J--)F.push(O>>>J&1)}var h=/^[0-9]*$/,B=/^[A-Z0-9 $%*+.\/:-]*$/;var _=new TextEncoder;class Q{constructor({mode:O,numChars:q,bitData:F,text:J}){this.mode=O,this.numChars=q,this.bitData=F,this.text=J}getData(){return this.bitData.slice()}}var N={numeric:{modeBits:1,numCharCountBits:(O)=>[10,12,14][Math.floor((O+7)/17)],test(O){return h.test(O)},write(O){let q=[];for(let F=0;F<O.length;){const J=Math.min(O.length-F,3);X(parseInt(O.substr(F,J),10),J*3+1,q),F+=J}return new Q({mode:"numeric",numChars:O.length,bitData:q,text:O})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(O)=>[9,11,13][Math.floor((O+7)/17)],test(O){return B.test(O)},write(O){let q=[],F;for(F=0;F+2<=O.length;F+=2){let J="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F))*45;J+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F+1)),X(J,11,q)}if(F<O.length)X("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F)),6,q);return new Q({mode:"alpha",numChars:O.length,bitData:q,text:O})}},byte:{modeBits:4,numCharCountBits:(O)=>[8,16,16][Math.floor((O+7)/17)],write(O){let q=_.encode(O),F=[];for(let J of q)X(J,8,F);return new Q({mode:"byte",numChars:q.length,bitData:F,text:O})}},kanji:{modeBits:8,numCharCountBits:(O)=>[8,10,12][Math.floor((O+7)/17)],write(O){throw Error("Not supporting kanji yet")}},eci:{modeBits:7,numCharCountBits:(O)=>[0,0,0][Math.floor((O+7)/17)],write(O){let q=[];if(O<0)throw new RangeError("ECI assignment value out of range");else if(O<1<<7)X(O,8,q);else if(O<1<<14)X(2,2,q),X(O,14,q);else if(O<1e6)X(6,3,q),X(O,21,q);else throw new RangeError("ECI assignment value out of range");return new Q(Mode.ECI,0,q)}}};function S(O){if(O<1||O>255)throw new RangeError("Degree out of range");let q=[];for(let J=0;J<O-1;J++)q.push(0);q.push(1);let F=1;for(let J=0;J<O;J++){for(let W=0;W<q.length;W++)if(q[W]=P(q[W],F),W+1<q.length)q[W]^=q[W+1];F=P(F,2)}return q}function z(O,q){let F=q.map((J)=>0);for(let J of O){const W=J^F.shift();F.push(0),q.forEach((T,Z)=>F[Z]^=P(T,W))}return F}function P(O,q){if(O>>>8!=0||q>>>8!=0)throw new RangeError("Byte out of range");let F=0;for(let J=7;J>=0;J--)F=F<<1^(F>>>7)*285,F^=(q>>>J&1)*O;return F}function k(O,{minVersion:q=1,maxVersion:F=40,minEcl:J="low"}={}){let W=q,T=J,Z,Y;for(;W<=F;W++){const I=R(W,T)*8;if(W==q||W==10||W==27)Y=u(O,W);const H=Math.ceil(Y.size/6);if(H<=I){Z=H;break}}if(!Z)throw Error("Data too long");let f=["low","medium","quartile","high"],K=f.slice(f.indexOf(J)+1);for(let I of K)if(Z<=R(W,I)*8)T=I;else break;return{version:W,ecl:T,bitstring:y(O,Y.steps,W,T)}}var u=function(O,q){const F={byte:(4+N.byte.numCharCountBits(q))*6,alpha:(4+N.alpha.numCharCountBits(q))*6,numeric:(4+N.numeric.numCharCountBits(q))*6};let J=[],W=Array.from(O).map((T,Z)=>{let Y={byte:v(O.codePointAt(Z))*8*6};if(N.alpha.test(T))Y.alpha=33;if(N.numeric.test(T))Y.numeric=20;return Y});Object.keys(W[0]).forEach((T)=>{J.push({size:F[T]+W[0][T],steps:[T]})});for(let T=1;T<W.length;T++){let Z=W[T],Y=[];for(let K=0;K<J.length;K++){let I=J[K];Object.keys(Z).forEach((H)=>{Y.push({size:I.steps[I.steps.length-1]==H?Z[H]+I.size:F[H]+Math.floor((I.size+5)/6)*6+Z[H],steps:[...I.steps,H]})})}let f=Math.min(...Y.map((K)=>K.size));J=Y.filter((K)=>K.size<=f+120)}return J.sort((T,Z)=>T.size-Z.size),J[0]};var y=function(O,q,F,J){let W=x(O,q),T=[];for(let $ of W){X(N[$.mode].modeBits,4,T),X($.numChars,N[$.mode].numCharCountBits(F),T);for(let L of $.getData())T.push(L)}const Z=R(F,J)*8;X(0,Math.min(4,Z-T.length),T),X(0,(8-T.length%8)%8,T);for(let $=236;T.length<Z;$^=236^17)X($,8,T);let Y=[];while(Y.length*8<T.length)Y.push(0);T.forEach(($,L)=>Y[L>>>3]|=$<<7-(L&7));const f=D[J].num_ecc_blocks[F],K=D[J].codewords_per_block[F],I=Math.floor(C(F)/8),H=f-I%f,V=Math.floor(I/f);let A=[];const j=S(K);for(let $=0,L=0;$<f;$++){let M=Y.slice(L,L+V-K+($<H?0:1));L+=M.length;const w=z(M,j);if($<H)M.push(0);A.push(M.concat(w))}let E=[];for(let $=0;$<A[0].length;$++)A.forEach((L,M)=>{if($!=V-K||M>=H)E.push(L[$])});return E.map(($)=>$.toString(2).padStart(8,"0")).join("")},v=function(O=128){if(O<0)throw"invalid";else if(O<128)return 1;else if(O<2048)return 2;else if(O<65536)return 3;else if(O<1114112)return 4;else throw"invalid"},C=function(O){let q=(16*O+128)*O+64;if(O>=2){const F=Math.floor(O/7)+2;q-=(25*F-10)*F-55,q-=O>=7?36:0}return q},R=function(O,q){return Math.floor(C(O)/8)-D[q].codewords_per_block[O]*D[q].num_ecc_blocks[O]};function x(O="",q=[]){let F=[],J=q[0],W=0;for(let T=1;T<=O.length;T++)if(T>=O.length||q[T]!=J){let Z=O.slice(W,T);F.push(N[J].write(Z)),J=q[T],W=T}return F}var b=[(O,q)=>(O+q)%2==0,(O,q)=>q%2==0,(O,q)=>O%3==0,(O,q)=>(O+q)%3==0,(O,q)=>(floor(O/3)+floor(q/2))%2==0,(O,q)=>O*q%2+O*q%3==0,(O,q)=>(O*q%2+O*q%3)%2==0,(O,q)=>((O+q)%2+O*q%3)%2==0];class G{constructor({version:O=2,ecl:q=0,mask:F=0,bitstring:J=""}={}){this.version=O,this.ecl=q,this.mask=F,this.bitstring=J}get size(){return this.version*4+17}get functional_patterns(){let{finder_patterns:O,timing_patterns:q,alignment_patterns:F,version_pattern:J,format_pattern:W}=this;return U.combine(O,q,F,J,W)}get finder_patterns(){let{size:O}=this,q=new U(O,O);for(let F=0;F<8;F++)for(let J=0;J<8;J++){let W=Math.max(Math.abs(3-F),Math.abs(3-J))!=2&&!(F==7||J==7);q.setPixel(F,J,W),q.setPixel(O-F-1,J,W),q.setPixel(F,O-J-1,W)}return q}get timing_patterns(){let{size:O}=this,q=new U(O,O);for(let F=8;F<=O-8;F++){let J=F%2==0;q.setPixel(6,F,J),q.setPixel(F,6,J)}return q}get alignment_positions(){let{version:O,size:q}=this;if(O==1)return[];const F=Math.floor(O/7)+2,J=O==32?26:Math.ceil((O*4+4)/(F*2-2))*2;let W=[6];for(let T=q-7;W.length<F;T-=J)W.splice(1,0,T);return W}get alignment_patterns(){let{version:O,size:q,alignment_positions:F}=this,J=new U(q,q);const W=F.length;for(let T=0;T<W;T++)for(let Z=0;Z<W;Z++)if(!(T==0&&Z==0||T==0&&Z==W-1||T==W-1&&Z==0))for(let Y=-2;Y<=2;Y++)for(let f=-2;f<=2;f++){let K=Math.max(Math.abs(f),Math.abs(Y))==1?0:1;J.setPixel(F[T]+f,F[Z]+Y,K)}return J}get format_pattern(){let{ecl:O,mask:q,size:F}=this,J=new U(F,F);const W=D[O].formatBits<<3|q;let T=W;for(let Y=0;Y<10;Y++)T=T<<1^(T>>>9)*1335;const Z=(W<<10|T)^21522;for(let Y=0;Y<=5;Y++)J.setPixel(8,Y,Z>>Y);J.setPixel(8,7,Z>>6),J.setPixel(8,8,Z>>7),J.setPixel(7,8,Z>>8);for(let Y=9;Y<15;Y++)J.setPixel(14-Y,8,Z>>Y);for(let Y=0;Y<8;Y++)J.setPixel(this.size-1-Y,8,Z>>Y);for(let Y=8;Y<15;Y++)J.setPixel(8,this.size-15+Y,Z>>Y);return J.setPixel(8,this.size-8,1),J}get version_pattern(){let{version:O,size:q}=this;const F=new U(q,q);if(O<7)return F;let J=O;for(let T=0;T<12;T++)J=J<<1^(J>>>11)*7973;const W=O<<12|J;for(let T=0;T<18;T++){const Z=q-11+T%3,Y=Math.floor(T/3);F.setPixel(Z,Y,W>>T),F.setPixel(Y,Z,W>>T)}return F}get data_pattern(){let{size:O,functional_patterns:q,bitstring:F,mask:J}=this;const W=new U(O,O);let T=0;for(let Z=O-1;Z>=1;Z-=2){if(Z==6)Z=5;for(let Y=0;Y<O;Y++)for(let f=0;f<2;f++){const K=Z-f,H=(Z+1&2)==0?O-1-Y:Y;if(!q.usedPixel(K,H)&&T<F.length){let A=parseInt(F[T]);A^=b[J](K,H),W.setPixel(K,H,A),T++}}}return W}get grid(){let{functional_patterns:O,data_pattern:q}=this;return U.combine(O,q)}}class U{constructor(O,q){this.arr=new Uint32Array(O*q),this.used=new Uint32Array(O*q),this.w=O,this.h=q}setPixel(O,q,F){let{w:J,h:W}=this;if(O<0||O>=J||q<0||q>=W)return;this.arr[q*J+O]=F&1,this.used[q*J+O]=1}getPixel(O,q){let{w:F,h:J}=this;if(O<0||O>=F||q<0||q>=J)return 0;return this.arr[q*F+O]}usedPixel(O,q){let{w:F,h:J}=this;if(O<0||O>=F||q<0||q>=J)return 0;return this.used[q*F+O]}toString(){let{w:O,h:q}=this,F="";for(let J=0;J<O;J++){for(let W=0;W<q;W++){let T=this.getPixel(J,W);F+=T?"@":" "}F+="\n"}return F}static combine(...O){let q=Math.max(...O.map((W)=>W.w)),F=Math.max(...O.map((W)=>W.h)),J=new U(q,F);for(let W=0;W<q;W++)for(let T=0;T<F;T++)if(O.some((Z)=>Z.usedPixel(W,T)))J.setPixel(W,T,O.some((Z)=>Z.getPixel(W,T)));return J}}var s=function(O,{minVersion:q=1,maxVersion:F=40,minEcl:J="low",mask:W=0}={}){let{version:T,ecl:Z,bitstring:Y}=k(O,{minVersion:q,minEcl:J,maxVersion:F});return new G({version:T,ecl:Z,mask:W,bitstring:Y})};export{k as findVersion,s as createQR,G as QRCode};
