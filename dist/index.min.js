var A={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function U(O,q,F){if(q<0||q>31||O>>>q!=0)throw new RangeError("Value out of range");for(let J=q-1;J>=0;J--)F.push(O>>>J&1)}var h=/^[0-9]*$/,w=/^[A-Z0-9 $%*+.\/:-]*$/;var u=new TextEncoder;class G{constructor({mode:O,numChars:q,bitData:F,text:J}){this.mode=O,this.numChars=q,this.bitData=F,this.text=J}getData(){return this.bitData.slice()}}var N={numeric:{modeBits:1,numCharCountBits:(O)=>[10,12,14][Math.floor((O+7)/17)],test(O){return h.test(O)},write(O){let q=[];for(let F=0;F<O.length;){const J=Math.min(O.length-F,3);U(parseInt(O.substr(F,J),10),J*3+1,q),F+=J}return new G({mode:"numeric",numChars:O.length,bitData:q,text:O})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(O)=>[9,11,13][Math.floor((O+7)/17)],test(O){return w.test(O)},write(O){let q=[],F;for(F=0;F+2<=O.length;F+=2){let J="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F))*45;J+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F+1)),U(J,11,q)}if(F<O.length)U("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(F)),6,q);return new G({mode:"alpha",numChars:O.length,bitData:q,text:O})}},byte:{modeBits:4,numCharCountBits:(O)=>[8,16,16][Math.floor((O+7)/17)],write(O){let q=u.encode(O),F=[];for(let J of q)U(J,8,F);return new G({mode:"byte",numChars:q.length,bitData:F,text:O})}}};function S(O){if(O<1||O>255)throw new RangeError("Degree out of range");let q=[];for(let J=0;J<O-1;J++)q.push(0);q.push(1);let F=1;for(let J=0;J<O;J++){for(let W=0;W<q.length;W++)if(q[W]=P(q[W],F),W+1<q.length)q[W]^=q[W+1];F=P(F,2)}return q}function k(O,q){let F=q.map((J)=>0);for(let J of O){const W=J^F.shift();F.push(0),q.forEach((T,Z)=>F[Z]^=P(T,W))}return F}function P(O,q){if(O>>>8!=0||q>>>8!=0)throw new RangeError("Byte out of range");let F=0;for(let J=7;J>=0;J--)F=F<<1^(F>>>7)*285,F^=(q>>>J&1)*O;return F}function C(O,{minVersion:q=1,maxVersion:F=40,minEcl:J="low"}={}){let W=q,T=J,Z,Y;for(;W<=F;W++){const X=R(W,T)*8;if(W==q||W==10||W==27)Y=_(O,W);const K=Y.size;if(K<=X){Z=K;break}}if(!Z)throw Error("Data too long");let f=["low","medium","quartile","high"],H=f.slice(f.indexOf(J)+1);for(let X of H)if(Z<=R(W,X)*8)T=X;else break;return{version:W,ecl:T,bitstring:v(O,Y.steps,W,T)}}function _(O,q=1){const F={byte:(4+N.byte.numCharCountBits(q))*6,alpha:(4+N.alpha.numCharCountBits(q))*6,numeric:(4+N.numeric.numCharCountBits(q))*6};let J=[],W=Array.from(O).map((T,Z)=>{let Y={byte:b(O.codePointAt(Z))*8*6};if(N.alpha.test(T))Y.alpha=33;if(N.numeric.test(T))Y.numeric=20;return Y});Object.keys(W[0]).forEach((T)=>{J.push({size:F[T]+W[0][T],steps:[T]})});for(let T=1;T<W.length;T++){let Z=W[T],Y=[],f=Infinity;for(let H=0;H<J.length;H++){let X=J[H];Object.keys(Z).forEach((K)=>{let M=K=="byte"?Array(Z[K]/48).fill(K):[K],D=X.steps[X.steps.length-1]==K?Z[K]+X.size:F[K]+Math.floor((X.size+5)/6)*6+Z[K];f=Math.min(f,D),Y.push({size:D,steps:[...X.steps,...M]})})}J=Y.filter((H)=>H.size<=f+[14,20,20][Math.floor((q+7)/17)]*6)}return J.sort((T,Z)=>T.size-Z.size),J=J.map((T)=>({steps:T.steps,size:Math.ceil(T.size/6)})),J[0]}var v=function(O,q,F,J){let W=x(O,q),T=[];for(let $ of W){U(N[$.mode].modeBits,4,T),U($.numChars,N[$.mode].numCharCountBits(F),T);for(let L of $.getData())T.push(L)}const Z=R(F,J)*8;U(0,Math.min(4,Z-T.length),T),U(0,(8-T.length%8)%8,T);for(let $=236;T.length<Z;$^=236^17)U($,8,T);let Y=[];while(Y.length*8<T.length)Y.push(0);T.forEach(($,L)=>Y[L>>>3]|=$<<7-(L&7));const f=A[J].num_ecc_blocks[F],H=A[J].codewords_per_block[F],X=Math.floor(B(F)/8),K=f-X%f,M=Math.floor(X/f);let D=[];const z=S(H);for(let $=0,L=0;$<f;$++){let Q=Y.slice(L,L+M-H+($<K?0:1));L+=Q.length;const j=k(Q,z);if($<K)Q.push(0);D.push(Q.concat(j))}let V=[];for(let $=0;$<D[0].length;$++)D.forEach((L,Q)=>{if($!=M-H||Q>=K)V.push(L[$])});return V.map(($)=>$.toString(2).padStart(8,"0")).join("")},b=function(O=128){if(O<0)throw"invalid";else if(O<128)return 1;else if(O<2048)return 2;else if(O<65536)return 3;else if(O<1114112)return 4;else throw"invalid"},B=function(O){let q=(16*O+128)*O+64;if(O>=2){const F=Math.floor(O/7)+2;q-=(25*F-10)*F-55,q-=O>=7?36:0}return q},R=function(O,q){return Math.floor(B(O)/8)-A[q].codewords_per_block[O]*A[q].num_ecc_blocks[O]};function x(O="",q=[]){let F=[],J=q[0],W=0;for(let T=1;T<=O.length;T++)if(T>=O.length||q[T]!=J){let Z=O.slice(W,T);F.push(N[J].write(Z)),J=q[T],W=T}return F}class I{constructor(O,q){this.arr=new Uint8Array(O*q),this.used=new Uint8Array(O*q),this.w=O,this.h=q}setPixel(O,q,F){let{w:J,h:W}=this;if(O<0||O>=J||q<0||q>=W)return;this.arr[q*J+O]=F&1,this.used[q*J+O]=1}getPixel(O,q){let{w:F,h:J}=this;if(O<0||O>=F||q<0||q>=J)return 0;return this.arr[q*F+O]}usedPixel(O,q){let{w:F,h:J}=this;if(O<0||O>=F||q<0||q>=J)return 0;return this.used[q*F+O]}static combine(...O){let q=Math.max(...O.map((W)=>W.w)),F=Math.max(...O.map((W)=>W.h)),J=new I(q,F);for(let W=0;W<q;W++)for(let T=0;T<F;T++)if(O.some((Z)=>Z.usedPixel(W,T)))J.setPixel(W,T,O.some((Z)=>Z.getPixel(W,T)));return J}}var y=[(O,q)=>(O+q)%2==0,(O,q)=>q%2==0,(O,q)=>O%3==0,(O,q)=>(O+q)%3==0,(O,q)=>(Math.floor(O/3)+Math.floor(q/2))%2==0,(O,q)=>O*q%2+O*q%3==0,(O,q)=>(O*q%2+O*q%3)%2==0,(O,q)=>((O+q)%2+O*q%3)%2==0];class E{constructor({version:O=2,ecl:q=0,mask:F=0,bitstring:J=""}={}){this.version=O,this.ecl=q,this.mask=F,this.bitstring=J}get size(){return this.version*4+17}get functional_patterns(){let{finder_patterns:O,timing_patterns:q,alignment_patterns:F,version_pattern:J,format_pattern:W}=this;return I.combine(O,q,F,J,W)}get finder_patterns(){let{size:O}=this,q=new I(O,O);for(let F=0;F<8;F++)for(let J=0;J<8;J++){let W=Math.max(Math.abs(3-F),Math.abs(3-J))!=2&&!(F==7||J==7);q.setPixel(F,J,W),q.setPixel(O-F-1,J,W),q.setPixel(F,O-J-1,W)}return q}get timing_patterns(){let{size:O}=this,q=new I(O,O);for(let F=8;F<=O-8;F++){let J=F%2==0;q.setPixel(6,F,J),q.setPixel(F,6,J)}return q}get alignment_positions(){let{version:O,size:q}=this;if(O==1)return[];const F=Math.floor(O/7)+2,J=O==32?26:Math.ceil((O*4+4)/(F*2-2))*2;let W=[6];for(let T=q-7;W.length<F;T-=J)W.splice(1,0,T);return W}get alignment_patterns(){let{version:O,size:q,alignment_positions:F}=this,J=new I(q,q);const W=F.length;for(let T=0;T<W;T++)for(let Z=0;Z<W;Z++)if(!(T==0&&Z==0||T==0&&Z==W-1||T==W-1&&Z==0))for(let Y=-2;Y<=2;Y++)for(let f=-2;f<=2;f++){let H=Math.max(Math.abs(f),Math.abs(Y))==1?0:1;J.setPixel(F[T]+f,F[Z]+Y,H)}return J}get format_pattern(){let{ecl:O,mask:q,size:F}=this,J=new I(F,F);const W=A[O].formatBits<<3|q;let T=W;for(let Y=0;Y<10;Y++)T=T<<1^(T>>>9)*1335;const Z=(W<<10|T)^21522;for(let Y=0;Y<=5;Y++)J.setPixel(8,Y,Z>>Y);J.setPixel(8,7,Z>>6),J.setPixel(8,8,Z>>7),J.setPixel(7,8,Z>>8);for(let Y=9;Y<15;Y++)J.setPixel(14-Y,8,Z>>Y);for(let Y=0;Y<8;Y++)J.setPixel(this.size-1-Y,8,Z>>Y);for(let Y=8;Y<15;Y++)J.setPixel(8,this.size-15+Y,Z>>Y);return J.setPixel(8,this.size-8,1),J}get version_pattern(){let{version:O,size:q}=this;const F=new I(q,q);if(O<7)return F;let J=O;for(let T=0;T<12;T++)J=J<<1^(J>>>11)*7973;const W=O<<12|J;for(let T=0;T<18;T++){const Z=q-11+T%3,Y=Math.floor(T/3);F.setPixel(Z,Y,W>>T),F.setPixel(Y,Z,W>>T)}return F}get data_pattern(){let{size:O,functional_patterns:q,bitstring:F,mask:J}=this;const W=new I(O,O);let T=0;for(let Z=O-1;Z>=1;Z-=2){if(Z==6)Z=5;for(let Y=0;Y<O;Y++)for(let f=0;f<2;f++){const H=Z-f,K=(Z+1&2)==0?O-1-Y:Y;if(!q.usedPixel(H,K)&&T<F.length){let D=parseInt(F[T]);D^=y[J](H,K),W.setPixel(H,K,D),T++}}}return W}get grid(){let{functional_patterns:O,data_pattern:q}=this;return I.combine(O,q)}}var O1=function(O,{minVersion:q=1,maxVersion:F=40,minEcl:J="low",mask:W=0}={}){let{version:T,ecl:Z,bitstring:Y}=C(O,{minVersion:q,minEcl:J,maxVersion:F});return new E({version:T,ecl:Z,mask:W,bitstring:Y})};export{C as findVersion,O1 as createQR,E as QRCode,I as PixelGrid};
