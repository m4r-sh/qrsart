var T=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var v=/^[0-9]*$/,m=/^[A-Z0-9 $%*+.\/:-]*$/;var f2=new TextEncoder,h2=[4,3,3],H2=[6,5],A={numeric:{modeBits:1,charCost:(f)=>v.test(f)?3.3333333333333335:1/0,numCharCountBits:(f)=>[10,12,14][Math.floor((f+7)/17)],groupSize:3,getMarginal:(f,h=0)=>v.test(f)?h2[h%3]:1/0,write(f){let h=[];for(let H=0;H<f.length;){let K=Math.min(f.length-H,3);I(parseInt(f.substr(H,K),10),K*3+1,h),H+=K}return h.slice()}},alpha:{modeBits:2,charCost:(f)=>m.test(f)?5.5:1/0,numCharCountBits:(f)=>[9,11,13][Math.floor((f+7)/17)],groupSize:2,getMarginal:(f,h=0)=>m.test(f)?H2[h%2]:1/0,write(f){let h=[],H;for(H=0;H+2<=f.length;H+=2){let K="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H))*45;K+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H+1)),I(K,11,h)}if(H<f.length)I("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H)),6,h);return h.slice()}},byte:{modeBits:4,charCost:(f)=>g(f)*8,groupSize:1,numCharCountBits:(f)=>[8,16,16][Math.floor((f+7)/17)],getMarginal:(f,h=0)=>g(f)*8,write(f){let h=f2.encode(f),H=[];for(let K of h)I(K,8,H);return H.slice()}}};function I(f,h,H){while(h>31)I(f>>>h-31,31,H),h-=31;if(f>>>h!==0)throw new RangeError("Value out of range");for(let K=h-1;K>=0;K--)H.push(f>>>K&1)}function g(f){let h=f.codePointAt(0);if(h<0)throw"invalid";else if(h<128)return 1;else if(h<2048)return 2;else if(h<65536)return 3;else if(h<1114112)return 4;else throw"invalid"}function n(f){if(f<1||f>255)throw new RangeError("Degree out of range");let h=[];for(let K=0;K<f-1;K++)h.push(0);h.push(1);let H=1;for(let K=0;K<f;K++){for(let W=0;W<h.length;W++)if(h[W]=x(h[W],H),W+1<h.length)h[W]^=h[W+1];H=x(H,2)}return h}function t(f,h){let H=h.map((K)=>0);for(let K of f){let W=K^H.shift();H.push(0),h.forEach((J,Q)=>H[Q]^=x(J,W))}return H}function x(f,h){if(f>>>8!=0||h>>>8!=0)throw new RangeError("Byte out of range");let H=0;for(let K=7;K>=0;K--)H=H<<1^(H>>>7)*285,H^=(h>>>K&1)*f;return H}function o(f,{minVersion:h=1,maxVersion:H=40,minEcl:K=0,maxEcl:W=3}={}){let J=h,Q=K,Y;if(A.numeric.charCost("1")*f.length>N(H,Q)*8)throw new Error("Data too long");for(;J<=H;J++){let $=N(J,Q)*8;if(J==h||J==10||J==27)Y=Y2(f,J);if(Y&&Y.cost<=$)break}if(!Y||Y.cost>N(J,Q)*8||J>H)throw new Error("Data too long");for(let $=Q+1;$<=W;$++)if(Y.cost<=N(J,$)*8)Q=$;else break;return{version:J,ecl:Q,codewords:a(f,Y,J,Q),strategy:Y}}function*K2(f,h,H){let K=N(h,H)*8,W=f.length,J=[{index:0,strategy:new M}];while(J.length){let{index:Q,strategy:Y}=J.pop();if(Q===W){Y.cost=Math.ceil(Y.cost),yield Y;continue}for(let $ of["byte","alpha","numeric"]){let F=A[$].charCost(f[Q]),B;if(F===1/0)continue;let L=(W-1-Q)*3.3333333333333335;if($==Y.mode){if(B=Y.cost+F,B>K-L)continue;let U=Y.addStep($,B,!1);J.push({index:Q+1,strategy:U})}let D=4+A[$].numCharCountBits(h);if(B=Math.ceil(Y.cost)+D+F,B>K-L)continue;let O=Y.addStep($,B,!0);J.push({index:Q+1,strategy:O})}}}var J2=["byte","numeric","alpha"],G=3,W2=5,E=W2*G,j={none:0,byte:1,numeric:2,alpha:3,kanji:4},k=[];k[j.none]="none";k[j.byte]="byte";k[j.numeric]="numeric";k[j.alpha]="alpha";k[j.kanji]="kanji";function Y2(f,h=1){let H=f.length,K=new Array(E).fill(null),W=j.none*G+0;K[W]=new M;for(let Y=1;Y<=H;Y++){let $=f[Y-1],F=new Array(E).fill(null);for(let B=0;B<E;B++){if(K[B]===null)continue;let L=K[B],D=Math.floor(B/G),O=B%G,U=k[D];if(U!=="none"){let V=A[U],q=V.getMarginal($,O);if(q!==1/0){let Z=(O+1)%V.groupSize,X=j[U]*G+Z,R=L.cost+q,_=L.addStep(U,R,!1);if(F[X]===null||_.cost<F[X].cost)F[X]=_}}for(let V of J2){let q=A[V],Z=q.getMarginal($,0);if(Z===1/0)continue;let X=4+q.numCharCountBits(h),R=L.cost+X+Z,_=1%q.groupSize,w=j[V]*G+_,l=L.addStep(V,R,!0);if(F[w]===null||l.cost<F[w].cost)F[w]=l}}K=F}let J=null,Q=1/0;for(let Y=0;Y<E;Y++)if(K[Y]!==null&&K[Y].cost<Q)Q=K[Y].cost,J=K[Y];return J}function a(f,h,H,K){let W=Q2(f,h),J=[];for(let{mode:q,str:Z}of W){I(A[q].modeBits,4,J),I(Z.length,A[q].numCharCountBits(H),J);for(let X of A[q].write(Z))J.push(X)}let Q=N(H,K)*8;I(0,Math.min(4,Q-J.length),J),I(0,(8-J.length%8)%8,J);for(let q=236;J.length<Q;q^=253)I(q,8,J);let Y=[];while(Y.length*8<J.length)Y.push(0);J.forEach((q,Z)=>Y[Z>>>3]|=q<<7-(Z&7));let $=T[K].num_ecc_blocks[H],F=T[K].codewords_per_block[H],B=Math.floor(s(H)/8),L=$-B%$,D=Math.floor(B/$),O=[],U=n(F);for(let q=0,Z=0;q<$;q++){let X=Y.slice(Z,Z+D-F+(q<L?0:1));Z+=X.length;let R=t(X,U);if(q<L)X.push(0);O.push(X.concat(R))}let V=[];for(let q=0;q<O[0].length;q++)O.forEach((Z,X)=>{if(q!=D-F||X>=L)V.push(Z[q])});return new Uint8Array(V)}function s(f){let h=(16*f+128)*f+64;if(f>=2){let H=Math.floor(f/7)+2;h-=(25*H-10)*H-55,h-=f>=7?36:0}return h}function N(f,h){return Math.floor(s(f)/8)-T[h].codewords_per_block[f]*T[h].num_ecc_blocks[f]}function Q2(f="",h={}){let H=[],K=0;for(let[W,J]of h.steps)H.push({mode:W,str:f.slice(K,K+J)}),K+=J;return H}class M{constructor(f=null,h="",H=0,K=0,W=!0){this.prev=f,this.mode=h,this.cost=H,this.length=K,this.isNewSegment=W,this._steps=null}addStep(f,h,H=!1){let K=H||f!==this.mode;return new M(this,f,h,this.length+1,K)}get steps(){if(this._steps)return this._steps;let f=[],h=this;while(h.prev)f.push({mode:h.mode,isNew:h.isNewSegment}),h=h.prev;f.reverse();let H=[],K=null,W=0;for(let{mode:J,isNew:Q}of f)if(Q||J!==K){if(W>0)H.push([K,W]);K=J,W=1}else W++;if(W>0)H.push([K,W]);return this._steps=H,this._steps}}var{floor:d}=Math,y=[(f,h)=>(f+h)%2==0,(f,h)=>h%2==0,(f,h)=>f%3==0,(f,h)=>(f+h)%3==0,(f,h)=>(d(f/3)+d(h/2))%2==0,(f,h)=>f*h%2+f*h%3==0,(f,h)=>(f*h%2+f*h%3)%2==0,(f,h)=>((f+h)%2+f*h%3)%2==0];class P{constructor(f,h){this.w=f,this.h=h;let K=f*h+31>>5;this.valueBits=new Uint32Array(K),this.usedBits=new Uint32Array(K)}#f(f,h){let H=h*this.w+f;return[H>>5,H&31]}set(f=0,h=0,H=1){if(f<0||f>=this.w||h<0||h>=this.h)return;let[K,W]=this.#f(f,h),J=1<<W;if(H&1)this.valueBits[K]|=J;else this.valueBits[K]&=~J;this.usedBits[K]|=J}get(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,K]=this.#f(f,h),W=1<<K;return this.valueBits[H]&W?1:0}used(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,K]=this.#f(f,h),W=1<<K;return this.usedBits[H]&W?1:0}*tiles(f=null){let{w:h,h:H,usedBits:K,valueBits:W}=this,J=h*H,Q=K.length;for(let Y=0;Y<Q;Y++){let $=K[Y];if($===0)continue;let F=W[Y],B=Y<<5;for(let L=0;L<32;L++){let D=B+L;if(D>=J)break;let O=1<<L;if(!($&O))continue;let U=(F&O)!==0;if(f==null||!f==!U)yield[D%h,Math.floor(D/h)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let h=Math.max(...f.map((W)=>W.w)),H=Math.max(...f.map((W)=>W.h)),K=new P(h,H);for(let W of f)for(let[J,Q]of W.tiles())if(!K.get(J,Q))K.set(J,Q,W.get(J,Q));return K}static erase(f,...h){let H=new P(f.w,f.h);for(let[K,W]of f.tiles())if(!h.some((J)=>J.used(K,W)))H.set(K,W,f.get(K,W));return H}static intersect(f,...h){let H=new P(f.w,f.h);for(let[K,W]of f.tiles())if(h.every((J)=>J.used(K,W)))H.set(K,W,f.get(K,W));return H}static invert(f){let h=new P(f.w,f.h);for(let[H,K]of f.tiles())h.set(H,K,!f.get(H,K));return h}}var u=BigInt(58);function r(f){let h="",H=BigInt(0);for(let K of f)H=H*BigInt(256)+BigInt(K);while(H>0)h="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[Number(H%u)]+h,H=H/u;return h}function i(f){let h=new Map("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("").map((W,J)=>[W,BigInt(J)])),H=BigInt(0);for(let W of f){let J=h.get(W);if(J===void 0)throw new Error("Invalid Base58 character");H=H*u+J}let K=[];while(H>0)K.unshift(Number(H%BigInt(256))),H=H/BigInt(256);return new Uint8Array(K)}class z{constructor({version:f=2,ecl:h=0,mask:H=0,codewords:K=new Uint8Array}={}){this.version=f,this.ecl=h,this.mask=H,this.codewords=K}get size(){return this.version*4+17}get functional_grid(){let f=new P(this.size,this.size);return p(f,this),S(f,this),b(f,this),c(f,this),f}get finder_grid(){let f=new P(this.size,this.size);return p(f,this),f}get timing_grid(){let f=new P(this.size,this.size);return S(f,this),f}get alignment_grid(){let f=new P(this.size,this.size);return b(f,this),f}get format_grid(){let f=new P(this.size,this.size);return e(f,this),f}get version_grid(){let f=new P(this.size,this.size);return c(f,this),f}get data_grid(){let f=new P(this.size,this.size);return C(f,this,this.functional_grid),f}get rawdata_grid(){let f=new P(this.size,this.size);return C(f,this,this.functional_grid,!0),f}get grid(){let f=new P(this.size,this.size);return p(f,this),S(f,this),b(f,this),c(f,this),C(f,this),f}toBytes(){return new Uint8Array([this.version&255,(this.ecl&3)<<3|(this.mask&7)<<5,...this.codewords])}toString(){return r(this.toBytes())}static fromBytes(f){return new z({version:f[0],ecl:f[1]>>3&3,mask:f[1]>>5&7,codewords:f.slice(2)})}static fromString(f){return z.fromBytes(i(f))}}function C(f,h,H,K=!1){if(!H)H=f;let{codewords:W,mask:J,size:Q}=h;e(f,h);let Y=0;for(let $=Q-1;$>=1;$-=2){if($===6)$=5;for(let F=0;F<Q;F++)for(let B=0;B<2;B++){let L=$-B,O=($+1&2)===0?Q-1-F:F;if(!H.used(L,O)){let V=0;if(Y<W.length*8){let q=Math.floor(Y/8),Z=7-Y%8;V=W[q]>>Z&1}if(K!==!0)V^=y[J](L,O);f.set(L,O,V),Y++}}}}function p(f,{size:h}){for(let H=0;H<8;H++)for(let K=0;K<8;K++){let W=Math.max(Math.abs(3-H),Math.abs(3-K))!=2&&!(H==7||K==7);f.set(H,K,W),f.set(h-H-1,K,W),f.set(H,h-K-1,W)}}function S(f,{size:h}){for(let H=8;H<=h-8;H++){let K=H%2==0;f.set(6,H,K),f.set(H,6,K)}}function b(f,{size:h,version:H}){let K=$2(H,h),W=K.length;for(let J=0;J<W;J++)for(let Q=0;Q<W;Q++)if(!(J==0&&Q==0||J==0&&Q==W-1||J==W-1&&Q==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let F=Math.max(Math.abs($),Math.abs(Y))==1?0:1;f.set(K[J]+$,K[Q]+Y,F)}}function e(f,{ecl:h,mask:H,size:K}){let W=T[h].formatBits<<3|H,J=W;for(let Y=0;Y<10;Y++)J=J<<1^(J>>>9)*1335;let Q=(W<<10|J)^21522;for(let Y=0;Y<=5;Y++)f.set(8,Y,Q>>Y);f.set(8,7,Q>>6),f.set(8,8,Q>>7),f.set(7,8,Q>>8);for(let Y=9;Y<15;Y++)f.set(14-Y,8,Q>>Y);for(let Y=0;Y<8;Y++)f.set(K-1-Y,8,Q>>Y);for(let Y=8;Y<15;Y++)f.set(8,K-15+Y,Q>>Y);f.set(8,K-8,1)}function c(f,{version:h,size:H}){if(h<7)return;let K=h;for(let J=0;J<12;J++)K=K<<1^(K>>>11)*7973;let W=h<<12|K;for(let J=0;J<18;J++){let Q=H-11+J%3,Y=Math.floor(J/3);f.set(Q,Y,W>>J),f.set(Y,Q,W>>J)}}function $2(f,h){if(f==1)return[];let H=Math.floor(f/7)+2,K=f==32?26:Math.ceil((f*4+4)/(H*2-2))*2,W=[6];for(let J=h-7;W.length<H;J-=K)W.splice(1,0,J);return W}function _2(f="",{minVersion:h=1,maxVersion:H=40,minEcl:K=0,maxEcl:W=3,ecl:J=null,version:Q=null,mask:Y=0}={}){if(Q)h=H=Q;if(J)K=W=J;let $=o(f,{minVersion:h,minEcl:K,maxEcl:W,maxVersion:H});return new z({mask:Y,version:$.version,ecl:$.ecl,codewords:$.codewords})}export{o as optimalStrategy,_2 as createQR,a as constructCodewords,K2 as allStrategies,z as QRCode,y as MASK_SHAPES,P as Grid,T as ECLS};
