var A={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function L(O,f,q){if(f<0||f>31||O>>>f!=0)throw new RangeError("Value out of range");for(let F=f-1;F>=0;F--)q.push(O>>>F&1)}var w=/^[0-9]*$/,h=/^[A-Z0-9 $%*+.\/:-]*$/;var u=new TextEncoder;class V{constructor({mode:O,numChars:f,bitData:q,text:F}){this.mode=O,this.numChars=f,this.bitData=q,this.text=F}getData(){return this.bitData.slice()}}var D={numeric:{modeBits:1,numCharCountBits:(O)=>[10,12,14][Math.floor((O+7)/17)],test(O){return w.test(O)},write(O){let f=[];for(let q=0;q<O.length;){const F=Math.min(O.length-q,3);L(parseInt(O.substr(q,F),10),F*3+1,f),q+=F}return new V({mode:"numeric",numChars:O.length,bitData:f,text:O})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(O)=>[9,11,13][Math.floor((O+7)/17)],test(O){return h.test(O)},write(O){let f=[],q;for(q=0;q+2<=O.length;q+=2){let F="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q))*45;F+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q+1)),L(F,11,f)}if(q<O.length)L("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q)),6,f);return new V({mode:"alpha",numChars:O.length,bitData:f,text:O})}},byte:{modeBits:4,numCharCountBits:(O)=>[8,16,16][Math.floor((O+7)/17)],write(O){let f=u.encode(O),q=[];for(let F of f)L(F,8,q);return new V({mode:"byte",numChars:f.length,bitData:q,text:O})}}};function G(O){if(O<1||O>255)throw new RangeError("Degree out of range");let f=[];for(let F=0;F<O-1;F++)f.push(0);f.push(1);let q=1;for(let F=0;F<O;F++){for(let T=0;T<f.length;T++)if(f[T]=E(f[T],q),T+1<f.length)f[T]^=f[T+1];q=E(q,2)}return f}function C(O,f){let q=f.map((F)=>0);for(let F of O){const T=F^q.shift();q.push(0),f.forEach((J,Y)=>q[Y]^=E(J,T))}return q}function E(O,f){if(O>>>8!=0||f>>>8!=0)throw new RangeError("Byte out of range");let q=0;for(let F=7;F>=0;F--)q=q<<1^(q>>>7)*285,q^=(f>>>F&1)*O;return q}function k(O,{minVersion:f=1,maxVersion:q=40,minEcl:F="low"}={}){let T=f,J=F,Y,W;for(;T<=q;T++){const X=P(T,J)*8;if(T==f||T==10||T==27)W=_(O,T);const K=W.size;if(K<=X){Y=K;break}}if(!Y)throw Error("Data too long");let $=["low","medium","quartile","high"],H=$.slice($.indexOf(F)+1);for(let X of H)if(Y<=P(T,X)*8)J=X;else break;return{version:T,ecl:J,bitstring:v(O,W.steps,T,J)}}function _(O,f=1){const q={byte:(4+D.byte.numCharCountBits(f))*6,alpha:(4+D.alpha.numCharCountBits(f))*6,numeric:(4+D.numeric.numCharCountBits(f))*6};let F=[],T=Array.from(O).map((J,Y)=>{let W={byte:b(O.codePointAt(Y))*8*6};if(D.alpha.test(J))W.alpha=33;if(D.numeric.test(J))W.numeric=20;return W});Object.keys(T[0]).forEach((J)=>{F.push({size:q[J]+T[0][J],steps:[J]})});for(let J=1;J<T.length;J++){let Y=T[J],W=[],$=Infinity;for(let H=0;H<F.length;H++){let X=F[H];Object.keys(Y).forEach((K)=>{let M=K=="byte"?Array(Y[K]/48).fill(K):[K],N=X.steps[X.steps.length-1]==K?Y[K]+X.size:q[K]+Math.floor((X.size+5)/6)*6+Y[K];$=Math.min($,N),W.push({size:N,steps:[...X.steps,...M]})})}F=W.filter((H)=>H.size<=$+[14,20,20][Math.floor((f+7)/17)]*6)}return F.sort((J,Y)=>J.size-Y.size),F=F.map((J)=>({steps:J.steps,size:Math.ceil(J.size/6)})),F[0]}var v=function(O,f,q,F){let T=y(O,f),J=[];for(let Z of T){L(D[Z.mode].modeBits,4,J),L(Z.numChars,D[Z.mode].numCharCountBits(q),J);for(let I of Z.getData())J.push(I)}const Y=P(q,F)*8;L(0,Math.min(4,Y-J.length),J),L(0,(8-J.length%8)%8,J);for(let Z=236;J.length<Y;Z^=236^17)L(Z,8,J);let W=[];while(W.length*8<J.length)W.push(0);J.forEach((Z,I)=>W[I>>>3]|=Z<<7-(I&7));const $=A[F].num_ecc_blocks[q],H=A[F].codewords_per_block[q],X=Math.floor(B(q)/8),K=$-X%$,M=Math.floor(X/$);let N=[];const j=G(H);for(let Z=0,I=0;Z<$;Z++){let Q=W.slice(I,I+M-H+(Z<K?0:1));I+=Q.length;const z=C(Q,j);if(Z<K)Q.push(0);N.push(Q.concat(z))}let R=[];for(let Z=0;Z<N[0].length;Z++)N.forEach((I,Q)=>{if(Z!=M-H||Q>=K)R.push(I[Z])});return R.map((Z)=>Z.toString(2).padStart(8,"0")).join("")},b=function(O=128){if(O<0)throw"invalid";else if(O<128)return 1;else if(O<2048)return 2;else if(O<65536)return 3;else if(O<1114112)return 4;else throw"invalid"},B=function(O){let f=(16*O+128)*O+64;if(O>=2){const q=Math.floor(O/7)+2;f-=(25*q-10)*q-55,f-=O>=7?36:0}return f},P=function(O,f){return Math.floor(B(O)/8)-A[f].codewords_per_block[O]*A[f].num_ecc_blocks[O]};function y(O="",f=[]){let q=[],F=f[0],T=0;for(let J=1;J<=O.length;J++)if(J>=O.length||f[J]!=F){let Y=O.slice(T,J);q.push(D[F].write(Y)),F=f[J],T=J}return q}var x=[(O,f)=>(O+f)%2==0,(O,f)=>f%2==0,(O,f)=>O%3==0,(O,f)=>(O+f)%3==0,(O,f)=>(floor(O/3)+floor(f/2))%2==0,(O,f)=>O*f%2+O*f%3==0,(O,f)=>(O*f%2+O*f%3)%2==0,(O,f)=>((O+f)%2+O*f%3)%2==0];class S{constructor({version:O=2,ecl:f=0,mask:q=0,bitstring:F=""}={}){this.version=O,this.ecl=f,this.mask=q,this.bitstring=F}get size(){return this.version*4+17}get functional_patterns(){let{finder_patterns:O,timing_patterns:f,alignment_patterns:q,version_pattern:F,format_pattern:T}=this;return U.combine(O,f,q,F,T)}get finder_patterns(){let{size:O}=this,f=new U(O,O);for(let q=0;q<8;q++)for(let F=0;F<8;F++){let T=Math.max(Math.abs(3-q),Math.abs(3-F))!=2&&!(q==7||F==7);f.setPixel(q,F,T),f.setPixel(O-q-1,F,T),f.setPixel(q,O-F-1,T)}return f}get timing_patterns(){let{size:O}=this,f=new U(O,O);for(let q=8;q<=O-8;q++){let F=q%2==0;f.setPixel(6,q,F),f.setPixel(q,6,F)}return f}get alignment_positions(){let{version:O,size:f}=this;if(O==1)return[];const q=Math.floor(O/7)+2,F=O==32?26:Math.ceil((O*4+4)/(q*2-2))*2;let T=[6];for(let J=f-7;T.length<q;J-=F)T.splice(1,0,J);return T}get alignment_patterns(){let{version:O,size:f,alignment_positions:q}=this,F=new U(f,f);const T=q.length;for(let J=0;J<T;J++)for(let Y=0;Y<T;Y++)if(!(J==0&&Y==0||J==0&&Y==T-1||J==T-1&&Y==0))for(let W=-2;W<=2;W++)for(let $=-2;$<=2;$++){let H=Math.max(Math.abs($),Math.abs(W))==1?0:1;F.setPixel(q[J]+$,q[Y]+W,H)}return F}get format_pattern(){let{ecl:O,mask:f,size:q}=this,F=new U(q,q);const T=A[O].formatBits<<3|f;let J=T;for(let W=0;W<10;W++)J=J<<1^(J>>>9)*1335;const Y=(T<<10|J)^21522;for(let W=0;W<=5;W++)F.setPixel(8,W,Y>>W);F.setPixel(8,7,Y>>6),F.setPixel(8,8,Y>>7),F.setPixel(7,8,Y>>8);for(let W=9;W<15;W++)F.setPixel(14-W,8,Y>>W);for(let W=0;W<8;W++)F.setPixel(this.size-1-W,8,Y>>W);for(let W=8;W<15;W++)F.setPixel(8,this.size-15+W,Y>>W);return F.setPixel(8,this.size-8,1),F}get version_pattern(){let{version:O,size:f}=this;const q=new U(f,f);if(O<7)return q;let F=O;for(let J=0;J<12;J++)F=F<<1^(F>>>11)*7973;const T=O<<12|F;for(let J=0;J<18;J++){const Y=f-11+J%3,W=Math.floor(J/3);q.setPixel(Y,W,T>>J),q.setPixel(W,Y,T>>J)}return q}get data_pattern(){let{size:O,functional_patterns:f,bitstring:q,mask:F}=this;const T=new U(O,O);let J=0;for(let Y=O-1;Y>=1;Y-=2){if(Y==6)Y=5;for(let W=0;W<O;W++)for(let $=0;$<2;$++){const H=Y-$,K=(Y+1&2)==0?O-1-W:W;if(!f.usedPixel(H,K)&&J<q.length){let N=parseInt(q[J]);N^=x[F](H,K),T.setPixel(H,K,N),J++}}}return T}get grid(){let{functional_patterns:O,data_pattern:f}=this;return U.combine(O,f)}}class U{constructor(O,f){this.arr=new Uint8Array(O*f),this.used=new Uint8Array(O*f),this.w=O,this.h=f}setPixel(O,f,q){let{w:F,h:T}=this;if(O<0||O>=F||f<0||f>=T)return;this.arr[f*F+O]=q&1,this.used[f*F+O]=1}getPixel(O,f){let{w:q,h:F}=this;if(O<0||O>=q||f<0||f>=F)return 0;return this.arr[f*q+O]}usedPixel(O,f){let{w:q,h:F}=this;if(O<0||O>=q||f<0||f>=F)return 0;return this.used[f*q+O]}static combine(...O){let f=Math.max(...O.map((T)=>T.w)),q=Math.max(...O.map((T)=>T.h)),F=new U(f,q);for(let T=0;T<f;T++)for(let J=0;J<q;J++)if(O.some((Y)=>Y.usedPixel(T,J)))F.setPixel(T,J,O.some((Y)=>Y.getPixel(T,J)));return F}}var s=function(O,{minVersion:f=1,maxVersion:q=40,minEcl:F="low",mask:T=0}={}){let{version:J,ecl:Y,bitstring:W}=k(O,{minVersion:f,minEcl:F,maxVersion:q});return new S({version:J,ecl:Y,mask:T,bitstring:W})};export{k as findVersion,s as createQR,S as QRCode};
