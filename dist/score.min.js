class L{constructor(E,K){this.w=E,this.h=K,this.data=new Uint8Array(Math.ceil(E*K/4))}#E(E,K){let J=K*this.w+E;return[J>>2,(J&3)<<1]}set(E=0,K=0,J=1){if(E<0||E>=this.w||K<0||K>=this.h)return;let[Q,M]=this.#E(E,K),Z=3<<M,$=(J&1)<<M|1<<M+1;this.data[Q]=this.data[Q]&~Z|$}get(E=0,K=0){if(E<0||E>=this.w||K<0||K>=this.h)return 0;let[J,Q]=this.#E(E,K);return this.data[J]>>Q&1}used(E=0,K=0){if(E<0||E>=this.w||K<0||K>=this.h)return 0;let[J,Q]=this.#E(E,K);return this.data[J]>>Q+1&1}*tiles(E=null){let{w:K,h:J,data:Q}=this,M=K*J;for(let Z=0;Z<Q.length;Z++){let $=Q[Z];if($===0)continue;let A=Z<<2;for(let R=0;R<4;R++){let q=A+R;if(q>=M)break;let B=R<<1;if(!($&2<<B))continue;let O=$&1<<B;if(E==null||!E==!O)yield[q%K,Math.floor(q/K)]}}}static union(...E){let K=Math.max(...E.map((M)=>M.w)),J=Math.max(...E.map((M)=>M.h)),Q=new L(K,J);for(let M of E)for(let[Z,$]of M.tiles())if(!Q.get(Z,$))Q.set(Z,$,M.get(Z,$));return Q}static erase(E,...K){let J=new L(E.w,E.h);for(let[Q,M]of E.tiles())if(!K.some((Z)=>Z.used(Q,M)))J.set(Q,M,E.get(Q,M));return J}static intersect(E,...K){let J=new L(E.w,E.h);for(let[Q,M]of E.tiles())if(K.every((Z)=>Z.used(Q,M)))J.set(Q,M,E.get(Q,M));return J}static invert(E){let K=new L(E.w,E.h);for(let[J,Q]of E.tiles())K.set(J,Q,!E.get(J,Q));return K}}function G(E,K){let J=[];return Object.keys(K).forEach((Q)=>{let M=K[Q];for(let[Z,$]of E.tiles()){let A=!0;try{M.points.forEach(([R,q,B=1])=>{A&=E.used(Z+R,$+q)&&E.get(Z+R,$+q)==B})}catch(R){A=!1}if(A)J.push([Q,[Z,$]])}}),J.map(([Q,[M,Z]])=>({shape:K[Q],coords:{x:M,y:Z}}))}class F{constructor(){this.left=this,this.right=this,this.up=this,this.down=this,this.column=null,this.rowId=null}}class k extends F{constructor(E){super();this.size=0,this.id=E}}function C(E,K,J=[],Q={score:0,valid_fits:[]},M=0,Z=new Set){if(J.length>Q.score)Q.score=J.length,Q.valid_fits=[...J];if(E.right===E)return Q;if(M>=K)return Q;let $=null,A=1/0;for(let R=E.right;R!==E;R=R.right)if(R.size<A&&R.size>0)A=R.size,$=R;if(!$||A===0)throw{done:!0,result:Q};f($),Z.add($.id.join(","));for(let R=$.down;R!==$;R=R.down){J.push(R.rowId);let q=[];for(let B=R.right;B!==R;B=B.right)if(!Z.has(B.column.id.join(",")))q.push(B.column),f(B.column),Z.add(B.column.id.join(","));C(E,K,J,Q,M+1,Z),J.pop();while(q.length){let B=q.pop();N(B),Z.delete(B.id.join(","))}}return N($),Z.delete($.id.join(",")),Q}function I(E,K){try{return C(E,K)}catch(J){if(J.done)return J.result;throw J}}function f(E){E.right.left=E.left,E.left.right=E.right;for(let K=E.down;K!==E;K=K.down)for(let J=K.right;J!==K;J=J.right)J.down.up=J.up,J.up.down=J.down,J.column.size--}function N(E){for(let K=E.up;K!==E;K=K.up)for(let J=K.left;J!==K;J=J.left)J.column.size++,J.down.up=J,J.up.down=J;E.right.left=E,E.left.right=E}function w(E,K){let J=G(E,K),{header:Q,columns:M}=j(E,J),Z=Q.right,$=Z.down;for(let O=0;O<10;O++){if($===Z)break;$=$.down}let{score:A,valid_fits:R}=I(Q,M),q=new L(E.w,E.h),B=[];R.forEach((O)=>{let{shape:T,coords:V}=J[O];T.points.forEach(([z,U])=>{q.set(V.x+z,V.y+U,1)}),B.push({shape:T,coords:V})});let _=L.erase(E,q);return{score:A,placements:B,used:q,unused:_}}function j(E,K){let J=[];for(let q=0;q<E.h;q++)for(let B=0;B<E.w;B++)if(E.get(B,q))J.push([B,q]);let Q=new F,M=J.map(([q,B])=>new k([q,B]));if(M.length>0){for(let q=0;q<M.length;q++){let B=M[q],_=q===0?Q:M[q-1],O=q===M.length-1?Q:M[q+1];B.left=_,B.right=O,_.right=B,O.left=B}Q.right=M[0],Q.left=M[M.length-1]}let Z=new Map(M.map((q)=>[`${q.id[0]},${q.id[1]}`,q])),$=[];K.forEach((q,B)=>{let{shape:_,coords:O}=q,T=[];_.points.forEach(([V,z])=>{let U=O.x+V,W=O.y+z,Y=`${U},${W}`;if(Z.has(Y))T.push(Z.get(Y))}),$.push({rowIdx:B,nodes:T})}),$.forEach(({rowIdx:q,nodes:B})=>{let _=B.map(()=>new F);B.forEach((O,T)=>{let V=_[T];V.column=O,V.rowId=q,V.down=O.down,V.up=O,O.down.up=V,O.down=V,O.size++,V.right=_[(T+1)%_.length],V.left=_[(T-1+_.length)%_.length]}),_.forEach((O,T)=>{O.right.left=O,O.left.right=O})});let A=Q.right,R=0;while(A!==Q&&R<J.length+1)A=A.right,R++;return{header:Q,columns:J.length}}function P(E,{diagonal:K=!1,value:J=!0}={}){let Q=new L(E.w,E.h),M=[];function Z($,A,R){if(!E.used($,A))return;if(E.get($,A)!=J||Q.get($,A))return;if(Q.set($,A,!0),R.push([$,A]),Z($-1,A,R),Z($+1,A,R),Z($,A-1,R),Z($,A+1,R),K)Z($-1,A-1,R),Z($+1,A-1,R),Z($-1,A+1,R),Z($+1,A+1,R)}for(let[$,A]of E.tiles(J))if(!Q.get($,A)){let R=[];Z($,A,R),M.push(R)}return M}function b(E){let K=new Set(E.map(([V,z])=>`${V},${z}`)),J=Math.max(...E.map((V)=>V[0]))+1,Q=Math.max(...E.map((V)=>V[1]))+1,M=[];for(let V=0;V<=J;V++)for(let z=0;z<Q;z++){let U=V>0&&K.has(`${V-1},${z}`),W=V<J&&K.has(`${V},${z}`);if(U!==W)M.push([V,z,"v"])}for(let V=0;V<=Q;V++)for(let z=0;z<J;z++){let U=V>0&&K.has(`${z},${V-1}`),W=V<Q&&K.has(`${z},${V}`);if(U!==W)M.push([z,V,"h"])}let Z=new Map;for(let V of M){let z,U;if(V[2]==="v")z=[V[0],V[1]],U=[V[0],V[1]+1];else z=[V[0],V[1]],U=[V[0]+1,V[1]];let W=`${z[0]},${z[1]}`,Y=`${U[0]},${U[1]}`;if(!Z.has(W))Z.set(W,[]);if(!Z.has(Y))Z.set(Y,[]);Z.get(W).push(V),Z.get(Y).push(V)}let $=new Set,A=[];for(let V of M){if($.has(V))continue;let z=[],U=V,W;if(U[2]==="v")W=[U[0],U[1]];else W=[U[0],U[1]];if(z.push([...W]),U[2]==="v")W=[U[0],U[1]+1];else W=[U[0]+1,U[1]];z.push([...W]),$.add(U);while(!0){let Y=`${W[0]},${W[1]}`,H=Z.get(Y).filter((X)=>X!==U&&!$.has(X));if(H.length===0)break;U=H[0],$.add(U);let D;if(U[2]==="v")if(W[0]===U[0]&&W[1]===U[1])D=[U[0],U[1]+1];else D=[U[0],U[1]];else if(W[0]===U[0]&&W[1]===U[1])D=[U[0]+1,U[1]];else D=[U[0],U[1]];if(z.push([...D]),W=D,D[0]===z[0][0]&&D[1]===z[0][1])break}A.push(z)}function R(V){let z=0;for(let U=0;U<V.length-1;U++)z+=V[U][0]*V[U+1][1]-V[U+1][0]*V[U][1];return z/2}function q(V){let z=1/0,U=1/0,W=-1/0,Y=-1/0;for(let[H,D]of V)z=Math.min(z,H),U=Math.min(U,D),W=Math.max(W,H),Y=Math.max(Y,D);return(W-z)*(Y-U)}let B=A.map((V)=>({path:V,signedArea:R(V),bbArea:q(V)})),_=B.reduce((V,z,U,W)=>z.bbArea>W[V].bbArea?U:V,0),O=B[_].path;if(B[_].signedArea<0)O.reverse();let T=B.filter((V,z)=>z!==_).map((V)=>V.path);for(let V of T)if(R(V)>0)V.reverse();return[O,...T]}export{C as solveDLX,w as packShapes,b as outlineShape,P as groupTiles,G as findFits,F as DLXNode,k as ColumnHeader};
