var Q={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function N(T,F,O){if(F<0||F>31||T>>>F!=0)throw new RangeError("Value out of range");for(let f=F-1;f>=0;f--)O.push(T>>>f&1)}var h=/^[0-9]*$/,u=/^[A-Z0-9 $%*+.\/:-]*$/;var v=new TextEncoder;class G{constructor({mode:T,numChars:F,bitData:O,text:f}){this.mode=T,this.numChars=F,this.bitData=O,this.text=f}getData(){return this.bitData.slice()}}var D={numeric:{modeBits:1,numCharCountBits:(T)=>[10,12,14][Math.floor((T+7)/17)],test(T){return h.test(T)},write(T){let F=[];for(let O=0;O<T.length;){const f=Math.min(T.length-O,3);N(parseInt(T.substr(O,f),10),f*3+1,F),O+=f}return new G({mode:"numeric",numChars:T.length,bitData:F,text:T})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(T)=>[9,11,13][Math.floor((T+7)/17)],test(T){return u.test(T)},write(T){let F=[],O;for(O=0;O+2<=T.length;O+=2){let f="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(O))*45;f+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(O+1)),N(f,11,F)}if(O<T.length)N("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(T.charAt(O)),6,F);return new G({mode:"alpha",numChars:T.length,bitData:F,text:T})}},byte:{modeBits:4,numCharCountBits:(T)=>[8,16,16][Math.floor((T+7)/17)],write(T){let F=v.encode(T),O=[];for(let f of F)N(f,8,O);return new G({mode:"byte",numChars:F.length,bitData:O,text:T})}}};function z(T){if(T<1||T>255)throw new RangeError("Degree out of range");let F=[];for(let f=0;f<T-1;f++)F.push(0);F.push(1);let O=1;for(let f=0;f<T;f++){for(let J=0;J<F.length;J++)if(F[J]=E(F[J],O),J+1<F.length)F[J]^=F[J+1];O=E(O,2)}return F}function B(T,F){let O=F.map((f)=>0);for(let f of T){const J=f^O.shift();O.push(0),F.forEach((q,W)=>O[W]^=E(q,J))}return O}function E(T,F){if(T>>>8!=0||F>>>8!=0)throw new RangeError("Byte out of range");let O=0;for(let f=7;f>=0;f--)O=O<<1^(O>>>7)*285,O^=(F>>>f&1)*T;return O}function k(T,{minVersion:F=1,maxVersion:O=40,minEcl:f="low"}={}){let J=F,q=f,W,Y;for(;J<=O;J++){const I=R(J,q)*8;if(J==F||J==10||J==27)Y=b(T,J);const K=Y.size;if(K<=I){W=K;break}}if(!W)throw Error("Data too long");let $=["low","medium","quartile","high"],H=$.slice($.indexOf(f)+1);for(let I of H)if(W<=R(J,I)*8)q=I;else break;return{version:J,ecl:q,bitstring:y(T,Y.steps,J,q)}}function b(T,F=1){const O={byte:(4+D.byte.numCharCountBits(F))*6,alpha:(4+D.alpha.numCharCountBits(F))*6,numeric:(4+D.numeric.numCharCountBits(F))*6};let f=[],J=Array.from(T).map((q,W)=>{let Y={byte:x(T.codePointAt(W))*8*6};if(D.alpha.test(q))Y.alpha=33;if(D.numeric.test(q))Y.numeric=20;return Y});Object.keys(J[0]).forEach((q)=>{f.push({size:O[q]+J[0][q],steps:[q]})});for(let q=1;q<J.length;q++){let W=J[q],Y=[],$=Infinity;for(let H=0;H<f.length;H++){let I=f[H];Object.keys(W).forEach((K)=>{let A=K=="byte"?Array(W[K]/48).fill(K):[K],X=I.steps[I.steps.length-1]==K?W[K]+I.size:O[K]+Math.floor((I.size+5)/6)*6+W[K];$=Math.min($,X),Y.push({size:X,steps:[...I.steps,...A]})})}f=Y.filter((H)=>H.size<=$+[14,20,20][Math.floor((F+7)/17)]*6)}return f.sort((q,W)=>q.size-W.size),f=f.map((q)=>({steps:q.steps,size:Math.ceil(q.size/6)})),f[0]}var y=function(T,F,O,f){let J=_(T,F),q=[];for(let Z of J){N(D[Z.mode].modeBits,4,q),N(Z.numChars,D[Z.mode].numCharCountBits(O),q);for(let U of Z.getData())q.push(U)}const W=R(O,f)*8;N(0,Math.min(4,W-q.length),q),N(0,(8-q.length%8)%8,q);for(let Z=236;q.length<W;Z^=236^17)N(Z,8,q);let Y=[];while(Y.length*8<q.length)Y.push(0);q.forEach((Z,U)=>Y[U>>>3]|=Z<<7-(U&7));const $=Q[f].num_ecc_blocks[O],H=Q[f].codewords_per_block[O],I=Math.floor(w(O)/8),K=$-I%$,A=Math.floor(I/$);let X=[];const P=z(H);for(let Z=0,U=0;Z<$;Z++){let M=Y.slice(U,U+A-H+(Z<K?0:1));U+=M.length;const j=B(M,P);if(Z<K)M.push(0);X.push(M.concat(j))}let V=[];for(let Z=0;Z<X[0].length;Z++)X.forEach((U,M)=>{if(Z!=A-H||M>=K)V.push(U[Z])});return V.map((Z)=>Z.toString(2).padStart(8,"0")).join("")},x=function(T=128){if(T<0)throw"invalid";else if(T<128)return 1;else if(T<2048)return 2;else if(T<65536)return 3;else if(T<1114112)return 4;else throw"invalid"},w=function(T){let F=(16*T+128)*T+64;if(T>=2){const O=Math.floor(T/7)+2;F-=(25*O-10)*O-55,F-=T>=7?36:0}return F},R=function(T,F){return Math.floor(w(T)/8)-Q[F].codewords_per_block[T]*Q[F].num_ecc_blocks[T]};function _(T="",F=[]){let O=[],f=F[0],J=0;for(let q=1;q<=T.length;q++)if(q>=T.length||F[q]!=f){let W=T.slice(J,q);O.push(D[f].write(W)),f=F[q],J=q}return O}class L{constructor(T,F){this.arr=new Uint8Array(T*F),this.used=new Uint8Array(T*F),this.w=T,this.h=F}setPixel(T=0,F=0,O=1){let{w:f,h:J}=this;if(T<0||T>=f||F<0||F>=J)return;this.arr[F*f+T]=O&1,this.used[F*f+T]=1}getPixel(T=0,F=0){let{w:O,h:f}=this;if(T<0||T>=O||F<0||F>=f)return 0;return this.arr[F*O+T]}usedPixel(T=0,F=0){let{w:O,h:f}=this;if(T<0||T>=O||F<0||F>=f)return 0;return this.used[F*O+T]}static combine(...T){let F=Math.max(...T.map((J)=>J.w)),O=Math.max(...T.map((J)=>J.h)),f=new L(F,O);for(let J=0;J<F;J++)for(let q=0;q<O;q++)if(T.some((W)=>W.usedPixel(J,q)))f.setPixel(J,q,T.some((W)=>W.getPixel(J,q)));return f}}var g=[(T,F)=>(T+F)%2==0,(T,F)=>F%2==0,(T,F)=>T%3==0,(T,F)=>(T+F)%3==0,(T,F)=>(Math.floor(T/3)+Math.floor(F/2))%2==0,(T,F)=>T*F%2+T*F%3==0,(T,F)=>(T*F%2+T*F%3)%2==0,(T,F)=>((T+F)%2+T*F%3)%2==0];class S{constructor({version:T=2,ecl:F=0,mask:O=0,bitstring:f="",data:J}={}){this.version=T,this.ecl=F,this.mask=O,this.bitstring=f,this.data=J}get size(){return this.version*4+17}get functional_grid(){let{finder_grid:T,timing_grid:F,alignment_grid:O,version_grid:f,format_grid:J}=this;return L.combine(T,F,O,f,J)}get finder_grid(){let{size:T}=this,F=new L(T,T);for(let O=0;O<8;O++)for(let f=0;f<8;f++){let J=Math.max(Math.abs(3-O),Math.abs(3-f))!=2&&!(O==7||f==7);F.setPixel(O,f,J),F.setPixel(T-O-1,f,J),F.setPixel(O,T-f-1,J)}return F}get timing_grid(){let{size:T}=this,F=new L(T,T);for(let O=8;O<=T-8;O++){let f=O%2==0;F.setPixel(6,O,f),F.setPixel(O,6,f)}return F}get alignment_positions(){let{version:T,size:F}=this;if(T==1)return[];const O=Math.floor(T/7)+2,f=T==32?26:Math.ceil((T*4+4)/(O*2-2))*2;let J=[6];for(let q=F-7;J.length<O;q-=f)J.splice(1,0,q);return J}get alignment_grid(){let{version:T,size:F,alignment_positions:O}=this,f=new L(F,F);const J=O.length;for(let q=0;q<J;q++)for(let W=0;W<J;W++)if(!(q==0&&W==0||q==0&&W==J-1||q==J-1&&W==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let H=Math.max(Math.abs($),Math.abs(Y))==1?0:1;f.setPixel(O[q]+$,O[W]+Y,H)}return f}get format_grid(){let{ecl:T,mask:F,size:O}=this,f=new L(O,O);const J=Q[T].formatBits<<3|F;let q=J;for(let Y=0;Y<10;Y++)q=q<<1^(q>>>9)*1335;const W=(J<<10|q)^21522;for(let Y=0;Y<=5;Y++)f.setPixel(8,Y,W>>Y);f.setPixel(8,7,W>>6),f.setPixel(8,8,W>>7),f.setPixel(7,8,W>>8);for(let Y=9;Y<15;Y++)f.setPixel(14-Y,8,W>>Y);for(let Y=0;Y<8;Y++)f.setPixel(this.size-1-Y,8,W>>Y);for(let Y=8;Y<15;Y++)f.setPixel(8,this.size-15+Y,W>>Y);return f.setPixel(8,this.size-8,1),f}get version_grid(){let{version:T,size:F}=this;const O=new L(F,F);if(T<7)return O;let f=T;for(let q=0;q<12;q++)f=f<<1^(f>>>11)*7973;const J=T<<12|f;for(let q=0;q<18;q++){const W=F-11+q%3,Y=Math.floor(q/3);O.setPixel(W,Y,J>>q),O.setPixel(Y,W,J>>q)}return O}get data_grid(){let{size:T,functional_grid:F,bitstring:O,mask:f}=this;const J=new L(T,T);let q=0;for(let W=T-1;W>=1;W-=2){if(W==6)W=5;for(let Y=0;Y<T;Y++)for(let $=0;$<2;$++){const H=W-$,K=(W+1&2)==0?T-1-Y:Y;if(!F.usedPixel(H,K)){let X=q<O.length?parseInt(O[q]):0;X^=g[f](H,K),J.setPixel(H,K,X),q++}}}return J}get grid(){let{functional_grid:T,data_grid:F}=this;return L.combine(T,F)}}function c(T="",F=""){let O=["T:WPA",`S:${T}`,`P:${F}`];return[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,1,0],[2,0,1]].map((f)=>`WIFI:${f.map((J)=>O[J]).join(";")};;`)}function m(T="m4r.sh/tetris",{protocols:F=["http","https"],protocol_caps:O=!0,domain_caps:f=!0,path_caps:J=!1}={}){if(!T.toLowerCase().startsWith("http"))T="http://"+T;let q=new URL(T),{hostname:W,pathname:Y,search:$,hash:H}=q,I=l({protocols:F,protocol_caps:O}),K=p({domain:W,domain_caps:f}),A=n({path:Y,path_caps:J}),X=[];return I.forEach((P)=>{K.forEach((V)=>{A.forEach((Z)=>{X.push(`${P}://${V}${Z}${$}${H}`)})})}),X}var l=function({protocols:T=["HTTP","HTTPS"],protocol_caps:F=!0}={}){let O=[];return T.forEach((f)=>{O.push(...F?C(f):[f])}),O},p=function({domain:T="M4R.SH",domain_caps:F=!0}={}){return F?C(T):[T]},n=function({path:T="/qr/tetris",path_caps:F=!1}={}){return F?C(T):[T]},C=function(T="tEsT"){let F=T.toLowerCase().split(""),O={};for(var f=0,J=1<<T.length;f<J;f++){for(var q=f,W=0;q;q>>=1,W++)F[W]=q&1?F[W].toUpperCase():F[W].toLowerCase();O[F.join("")]=!0}return Object.keys(O)};var Z1=function(T="",{minVersion:F=1,maxVersion:O=40,minEcl:f="low",mask:J=0}={}){let{version:q,ecl:W,bitstring:Y}=k(T,{minVersion:F,minEcl:f,maxVersion:O});return new S({data:T,version:q,ecl:W,mask:J,bitstring:Y})};export{c as permuteWIFI,m as permuteURL,k as findVersion,Z1 as createQR,S as QRCode,L as PixelGrid};
