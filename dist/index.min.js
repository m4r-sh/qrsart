var R=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var b=/^[0-9]*$/,l=/^[A-Z0-9 $%*+.\/:-]*$/;var m=new TextEncoder,A={numeric:{modeBits:1,charCost:(f)=>b.test(f)?3.3333333333333335:1/0,numCharCountBits:(f)=>[10,12,14][Math.floor((f+7)/17)],write(f){let K=[];for(let H=0;H<f.length;){let J=Math.min(f.length-H,3);I(parseInt(f.substr(H,J),10),J*3+1,K),H+=J}return K.slice()}},alpha:{modeBits:2,charCost:(f)=>l.test(f)?5.5:1/0,numCharCountBits:(f)=>[9,11,13][Math.floor((f+7)/17)],write(f){let K=[],H;for(H=0;H+2<=f.length;H+=2){let J="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H))*45;J+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H+1)),I(J,11,K)}if(H<f.length)I("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H)),6,K);return K.slice()}},byte:{modeBits:4,charCost:(f)=>g(f)*8,numCharCountBits:(f)=>[8,16,16][Math.floor((f+7)/17)],test:(f)=>!0,write(f){let K=m.encode(f),H=[];for(let J of K)I(J,8,H);return H.slice()}}};function I(f,K,H){while(K>31)I(f>>>K-31,31,H),K-=31;if(f>>>K!==0)throw new RangeError("Value out of range");for(let J=K-1;J>=0;J--)H.push(f>>>J&1)}function g(f){let K=f.codePointAt(0);if(K<0)throw"invalid";else if(K<128)return 1;else if(K<2048)return 2;else if(K<65536)return 3;else if(K<1114112)return 4;else throw"invalid"}function w(f){if(f<1||f>255)throw new RangeError("Degree out of range");let K=[];for(let J=0;J<f-1;J++)K.push(0);K.push(1);let H=1;for(let J=0;J<f;J++){for(let W=0;W<K.length;W++)if(K[W]=V(K[W],H),W+1<K.length)K[W]^=K[W+1];H=V(H,2)}return K}function x(f,K){let H=K.map((J)=>0);for(let J of f){let W=J^H.shift();H.push(0),K.forEach((P,Z)=>H[Z]^=V(P,W))}return H}function V(f,K){if(f>>>8!=0||K>>>8!=0)throw new RangeError("Byte out of range");let H=0;for(let J=7;J>=0;J--)H=H<<1^(H>>>7)*285,H^=(K>>>J&1)*f;return H}function k(f,{minVersion:K=1,maxVersion:H=40,minEcl:J=0,maxEcl:W=3}={}){let P=K,Z=J,Y;if(A.numeric.charCost("1")*f.length>L(H,Z)*8)throw new Error("Data too long");for(;P<=H;P++){let $=L(P,Z)*8;if(P==K||P==10||P==27)Y=n(f,P);if(Y&&Y.cost<=$)break}if(!Y||Y.cost>L(P,Z)*8||P>H)throw new Error("Data too long");for(let $=Z+1;$<=W;$++)if(Y.cost<=L(P,$)*8)Z=$;else break;return{version:P,ecl:Z,codewords:C(f,Y.steps,P,Z),cost:Y.cost,steps:Y.steps,strategy:o(Y.steps),budget:L(P,Z)*8}}function o(f){let K=f.map((W)=>["byte","numeric","alpha","kanji"].indexOf(W)),H=Math.ceil(K.length/4),J=new Uint8Array(H);for(let W=0;W<K.length;W++){let P=Math.floor(W/4),Z=(3-W%4)*2;J[P]|=(K[W]&3)<<Z}return J}function*t(f,K,H){let J=L(K,H)*8,W=f.length,P=[{index:0,strategy:new G}];while(P.length){let{index:Z,strategy:Y}=P.pop();if(Z===W){yield Y;continue}for(let $ of["byte","alpha","numeric"]){let T=A[$].charCost(f[Z]);if(T===1/0)continue;let h=Y.lastMode===$?0:4+A[$].numCharCountBits(K),O=Y.cost+h+T;if(Y.lastMode!==$)O=Math.ceil(O);let q=(W-1-Z)*3.3333333333333335;if(O>J-q)continue;let X=Y.addStep($,O);P.push({index:Z+1,strategy:X})}}}function n(f,K){let H=f.length,J=Array(H+1).fill().map(()=>({}));J[0][""]=new G;for(let Z=1;Z<=H;Z++)for(let Y in J[Z-1]){let $=J[Z-1][Y];for(let T of["numeric","alpha","byte"]){let h=A[T].charCost(f[Z-1]);if(h===1/0)continue;let O=$.lastMode===T?0:4+A[T].numCharCountBits(K),q=$.cost+O+h;if($.lastMode!==T)q=Math.ceil(q);let X=$.addStep(T,q),_=J[Z][T];if(!_||X.cost<_.cost)J[Z][T]=X}}let W=J[H],P=null;for(let Z in W)if(!P||W[Z].cost<P.cost)P=W[Z];return P?{steps:P.getSteps(),cost:P.cost}:null}function C(f,K,H,J){let W=a(f,K),P=[];for(let{mode:U,str:F}of W){I(A[U].modeBits,4,P),I(F.length,A[U].numCharCountBits(H),P);for(let M of A[U].write(F))P.push(M)}let Z=L(H,J)*8;I(0,Math.min(4,Z-P.length),P),I(0,(8-P.length%8)%8,P);for(let U=236;P.length<Z;U^=253)I(U,8,P);let Y=[];while(Y.length*8<P.length)Y.push(0);P.forEach((U,F)=>Y[F>>>3]|=U<<7-(F&7));let $=R[J].num_ecc_blocks[H],T=R[J].codewords_per_block[H],h=Math.floor(y(H)/8),O=$-h%$,q=Math.floor(h/$),X=[],_=w(T);for(let U=0,F=0;U<$;U++){let M=Y.slice(F,F+q-T+(U<O?0:1));F+=M.length;let v=x(M,_);if(U<O)M.push(0);X.push(M.concat(v))}let N=[];for(let U=0;U<X[0].length;U++)X.forEach((F,M)=>{if(U!=q-T||M>=O)N.push(F[U])});return new Uint8Array(N)}function y(f){let K=(16*f+128)*f+64;if(f>=2){let H=Math.floor(f/7)+2;K-=(25*H-10)*H-55,K-=f>=7?36:0}return K}function L(f,K){return Math.floor(y(f)/8)-R[K].codewords_per_block[f]*R[K].num_ecc_blocks[f]}function a(f="",K=[]){let H=[],J=K[0],W=0;for(let P=1;P<=f.length;P++)if(P>=f.length||K[P]!=J)H.push({mode:J,str:f.slice(W,P)}),J=K[P],W=P;return H}var s=["byte","numeric","alpha","kanji"],d={byte:0,numeric:1,alpha:2,kanji:3};class G{constructor(f=new Uint8Array(0),K=0,H=0,J=""){this.packed=f,this.length=K,this.cost=H,this.lastMode=J}addStep(f,K){let{length:H,packed:J}=this,W=Math.floor(H/4),P=(3-H%4)*2,Z=J.length+(W<J.length?0:1),Y=new Uint8Array(Z);return Y.set(J),Y[W]|=d[f]<<P,new G(Y,H+1,K,f)}getSteps(){return Array.from({length:this.length},(f,K)=>{let H=this.packed[Math.floor(K/4)],J=(3-K%4)*2;return s[H>>J&3]})}}var{floor:c}=Math,D=[(f,K)=>(f+K)%2==0,(f,K)=>K%2==0,(f,K)=>f%3==0,(f,K)=>(f+K)%3==0,(f,K)=>(c(f/3)+c(K/2))%2==0,(f,K)=>f*K%2+f*K%3==0,(f,K)=>(f*K%2+f*K%3)%2==0,(f,K)=>((f+K)%2+f*K%3)%2==0];class Q{constructor(f,K){this.w=f,this.h=K;let J=f*K+31>>5;this.valueBits=new Uint32Array(J),this.usedBits=new Uint32Array(J)}#f(f,K){let H=K*this.w+f;return[H>>5,H&31]}set(f=0,K=0,H=1){if(f<0||f>=this.w||K<0||K>=this.h)return;let[J,W]=this.#f(f,K),P=1<<W;if(H&1)this.valueBits[J]|=P;else this.valueBits[J]&=~P;this.usedBits[J]|=P}get(f=0,K=0){if(f<0||f>=this.w||K<0||K>=this.h)return 0;let[H,J]=this.#f(f,K),W=1<<J;return this.valueBits[H]&W?1:0}used(f=0,K=0){if(f<0||f>=this.w||K<0||K>=this.h)return 0;let[H,J]=this.#f(f,K),W=1<<J;return this.usedBits[H]&W?1:0}*tiles(f=null){let{w:K,h:H,usedBits:J,valueBits:W}=this,P=K*H,Z=J.length;for(let Y=0;Y<Z;Y++){let $=J[Y];if($===0)continue;let T=W[Y],h=Y<<5;for(let O=0;O<32;O++){let q=h+O;if(q>=P)break;let X=1<<O;if(!($&X))continue;let _=(T&X)!==0;if(f==null||!f==!_)yield[q%K,Math.floor(q/K)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let K=Math.max(...f.map((W)=>W.w)),H=Math.max(...f.map((W)=>W.h)),J=new Q(K,H);for(let W of f)for(let[P,Z]of W.tiles())if(!J.get(P,Z))J.set(P,Z,W.get(P,Z));return J}static erase(f,...K){let H=new Q(f.w,f.h);for(let[J,W]of f.tiles())if(!K.some((P)=>P.used(J,W)))H.set(J,W,f.get(J,W));return H}static intersect(f,...K){let H=new Q(f.w,f.h);for(let[J,W]of f.tiles())if(K.every((P)=>P.used(J,W)))H.set(J,W,f.get(J,W));return H}static invert(f){let K=new Q(f.w,f.h);for(let[H,J]of f.tiles())K.set(H,J,!f.get(H,J));return K}}class B{constructor({version:f=2,ecl:K=0,mask:H=0,codewords:J=new Uint8Array}={}){this.version=f,this.ecl=K,this.mask=H,this.codewords=J}get size(){return this.version*4+17}get functional_grid(){let f=new Q(this.size,this.size);return j(f,this),z(f,this),S(f,this),u(f,this),f}get finder_grid(){let f=new Q(this.size,this.size);return j(f,this),f}get timing_grid(){let f=new Q(this.size,this.size);return z(f,this),f}get alignment_grid(){let f=new Q(this.size,this.size);return S(f,this),f}get format_grid(){let f=new Q(this.size,this.size);return p(f,this),f}get version_grid(){let f=new Q(this.size,this.size);return u(f,this),f}get data_grid(){let f=new Q(this.size,this.size);return E(f,this,this.functional_grid),f}get rawdata_grid(){let f=new Q(this.size,this.size);return E(f,this,this.functional_grid,!0),f}get grid(){let f=new Q(this.size,this.size);return j(f,this),z(f,this),S(f,this),u(f,this),E(f,this),f}toBytes(){return new Uint8Array([this.version&255,(this.ecl&3)<<3|(this.mask&7)<<5,...this.codewords])}toString(){let f=this.toBytes(),K="";return f.forEach((H)=>K+=String.fromCharCode(H)),btoa(K)}static fromBytes(f){return new B({version:f[0],ecl:f[1]>>3&3,mask:f[1]>>5&7,codewords:f.slice(2)})}static fromString(f){return B.fromBytes(Uint8Array.from(atob(f),(K)=>K.charCodeAt(0)))}}function E(f,K,H,J=!1){if(!H)H=f;let{codewords:W,mask:P,size:Z}=K;p(f,K);let Y=0;for(let $=Z-1;$>=1;$-=2){if($===6)$=5;for(let T=0;T<Z;T++)for(let h=0;h<2;h++){let O=$-h,X=($+1&2)===0?Z-1-T:T;if(!H.used(O,X)){let N=0;if(Y<W.length*8){let U=Math.floor(Y/8),F=7-Y%8;N=W[U]>>F&1}if(J!==!0)N^=D[P](O,X);f.set(O,X,N),Y++}}}}function j(f,{size:K}){for(let H=0;H<8;H++)for(let J=0;J<8;J++){let W=Math.max(Math.abs(3-H),Math.abs(3-J))!=2&&!(H==7||J==7);f.set(H,J,W),f.set(K-H-1,J,W),f.set(H,K-J-1,W)}}function z(f,{size:K}){for(let H=8;H<=K-8;H++){let J=H%2==0;f.set(6,H,J),f.set(H,6,J)}}function S(f,{size:K,version:H}){let J=r(H,K),W=J.length;for(let P=0;P<W;P++)for(let Z=0;Z<W;Z++)if(!(P==0&&Z==0||P==0&&Z==W-1||P==W-1&&Z==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let T=Math.max(Math.abs($),Math.abs(Y))==1?0:1;f.set(J[P]+$,J[Z]+Y,T)}}function p(f,{ecl:K,mask:H,size:J}){let W=R[K].formatBits<<3|H,P=W;for(let Y=0;Y<10;Y++)P=P<<1^(P>>>9)*1335;let Z=(W<<10|P)^21522;for(let Y=0;Y<=5;Y++)f.set(8,Y,Z>>Y);f.set(8,7,Z>>6),f.set(8,8,Z>>7),f.set(7,8,Z>>8);for(let Y=9;Y<15;Y++)f.set(14-Y,8,Z>>Y);for(let Y=0;Y<8;Y++)f.set(J-1-Y,8,Z>>Y);for(let Y=8;Y<15;Y++)f.set(8,J-15+Y,Z>>Y);f.set(8,J-8,1)}function u(f,{version:K,size:H}){if(K<7)return;let J=K;for(let P=0;P<12;P++)J=J<<1^(J>>>11)*7973;let W=K<<12|J;for(let P=0;P<18;P++){let Z=H-11+P%3,Y=Math.floor(P/3);f.set(Z,Y,W>>P),f.set(Y,Z,W>>P)}}function r(f,K){if(f==1)return[];let H=Math.floor(f/7)+2,J=f==32?26:Math.ceil((f*4+4)/(H*2-2))*2,W=[6];for(let P=K-7;W.length<H;P-=J)W.splice(1,0,P);return W}function F2(f="",{minVersion:K=1,maxVersion:H=40,minEcl:J=0,maxEcl:W=3,ecl:P=null,version:Z=null,mask:Y=0}={}){if(Z)K=H=Z;if(P)J=W=P;let $=k(f,{minVersion:K,minEcl:J,maxEcl:W,maxVersion:H});return new B({mask:Y,version:$.version,ecl:$.ecl,codewords:$.codewords})}export{k as optimalStrategy,F2 as createQR,C as constructCodewords,t as allStrategies,B as QRCode,D as MASK_SHAPES,Q as Grid,R as ECLS};
