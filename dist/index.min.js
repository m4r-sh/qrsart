var N=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var h=/^[0-9]*$/,x=/^[A-Z0-9 $%*+.\/:-]*$/;var u=new TextEncoder,A={numeric:{modeBits:1,charCost:(Q)=>h.test(Q)?3.3333333333333335:1/0,numCharCountBits:(Q)=>[10,12,14][Math.floor((Q+7)/17)],write(Q){let q=[];for(let J=0;J<Q.length;){let K=Math.min(Q.length-J,3);P(parseInt(Q.substr(J,K),10),K*3+1,q),J+=K}return q.slice()}},alpha:{modeBits:2,charCost:(Q)=>x.test(Q)?5.5:1/0,numCharCountBits:(Q)=>[9,11,13][Math.floor((Q+7)/17)],write(Q){let q=[],J;for(J=0;J+2<=Q.length;J+=2){let K="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(Q.charAt(J))*45;K+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(Q.charAt(J+1)),P(K,11,q)}if(J<Q.length)P("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(Q.charAt(J)),6,q);return q.slice()}},byte:{modeBits:4,charCost:(Q)=>y(Q)*8,numCharCountBits:(Q)=>[8,16,16][Math.floor((Q+7)/17)],test:(Q)=>!0,write(Q){let q=u.encode(Q),J=[];for(let K of q)P(K,8,J);return J.slice()}}};function P(Q,q,J){while(q>31)P(Q>>>q-31,31,J),q-=31;if(Q>>>q!==0)throw new RangeError("Value out of range");for(let K=q-1;K>=0;K--)J.push(Q>>>K&1)}function y(Q){let q=Q.codePointAt(0);if(q<0)throw"invalid";else if(q<128)return 1;else if(q<2048)return 2;else if(q<65536)return 3;else if(q<1114112)return 4;else throw"invalid"}function f(Q){if(Q<1||Q>255)throw new RangeError("Degree out of range");let q=[];for(let K=0;K<Q-1;K++)q.push(0);q.push(1);let J=1;for(let K=0;K<Q;K++){for(let W=0;W<q.length;W++)if(q[W]=G(q[W],J),W+1<q.length)q[W]^=q[W+1];J=G(J,2)}return q}function S(Q,q){let J=q.map((K)=>0);for(let K of Q){let W=K^J.shift();J.push(0),q.forEach((T,Z)=>J[Z]^=G(T,W))}return J}function G(Q,q){if(Q>>>8!=0||q>>>8!=0)throw new RangeError("Byte out of range");let J=0;for(let K=7;K>=0;K--)J=J<<1^(J>>>7)*285,J^=(q>>>K&1)*Q;return J}function z(Q,{minVersion:q=1,maxVersion:J=40,minEcl:K=0,maxEcl:W=3}={}){let T=q,Z=K,Y;if(A.numeric.charCost("1")*Q.length>V(J,Z)*8)throw new Error("Data too long");for(;T<=J;T++){let $=V(T,Z)*8;if(T==q||T==10||T==27)Y=p(Q,T);if(Y&&Y.cost<=$)break}if(!Y||Y.cost>V(T,Z)*8||T>J)throw new Error("Data too long");for(let $=Z+1;$<=W;$++)if(Y.cost<=V(T,$)*8)Z=$;else break;return{version:T,ecl:Z,codewords:j(Q,Y.steps,T,Z),cost:Y.cost,steps:Y.steps,strategy:B(Y.steps),budget:V(T,Z)*8}}function B(Q){let q=Q.map((W)=>["byte","numeric","alpha","kanji"].indexOf(W)),J=Math.ceil(q.length/4),K=new Uint8Array(J);for(let W=0;W<q.length;W++){let T=Math.floor(W/4),Z=(3-W%4)*2;K[T]|=(q[W]&3)<<Z}return K}function b(Q,q,J){let K=V(q,J)*8,W=Q.length,T=[{cost:0,steps:[],mode:""}];for(let Z=0;Z<W;Z++){let Y=[];for(let $ of T)for(let F of["numeric","alpha","byte"]){let O=A[F].charCost(Q[Z]);if(O===1/0)continue;let H=$.mode===F?0:4+A[F].numCharCountBits(q),R=$.cost+H+O;if(R>K)continue;Y.push({cost:R,steps:[...$.steps,F],strategy:B($.steps),mode:F})}T=Y}return T}function p(Q,q){let J=Q.length,K=Array(J+1).fill().map(()=>({}));K[0]={"":{cost:0,steps:[]}};let W=0;for(let $=1;$<=J;$++)for(let F in K[$-1]){let O=K[$-1][F];for(let H of["numeric","alpha","byte"]){let R=A[H].charCost(Q[$-1]);if(R===1/0)continue;let I=F===H?0:4+A[H].numCharCountBits(q),L=O.cost+I+R;if(!K[$][H]||L<K[$][H].cost)K[$][H]={cost:L,steps:[...O.steps,H]}}}let T=K[J],Z=1/0,Y="";for(let $ in T)if(T[$].cost<Z)Z=T[$].cost,Y=$;return T[Y]?{steps:T[Y].steps,cost:T[Y].cost}:null}function j(Q,q,J,K){let W=v(Q,q),T=[];for(let{mode:X,str:_}of W){P(A[X].modeBits,4,T),P(_.length,A[X].numCharCountBits(J),T);for(let D of A[X].write(_))T.push(D)}let Z=V(J,K)*8;P(0,Math.min(4,Z-T.length),T),P(0,(8-T.length%8)%8,T);for(let X=236;T.length<Z;X^=253)P(X,8,T);let Y=[];while(Y.length*8<T.length)Y.push(0);T.forEach((X,_)=>Y[_>>>3]|=X<<7-(_&7));let $=N[K].num_ecc_blocks[J],F=N[K].codewords_per_block[J],O=Math.floor(k(J)/8),H=$-O%$,R=Math.floor(O/$),I=[],L=f(F);for(let X=0,_=0;X<$;X++){let D=Y.slice(_,_+R-F+(X<H?0:1));_+=D.length;let C=S(D,L);if(X<H)D.push(0);I.push(D.concat(C))}let M=[];for(let X=0;X<I[0].length;X++)I.forEach((_,D)=>{if(X!=R-F||D>=H)M.push(_[X])});return new Uint8Array(M)}function k(Q){let q=(16*Q+128)*Q+64;if(Q>=2){let J=Math.floor(Q/7)+2;q-=(25*J-10)*J-55,q-=Q>=7?36:0}return q}function V(Q,q){return Math.floor(k(Q)/8)-N[q].codewords_per_block[Q]*N[q].num_ecc_blocks[Q]}function v(Q="",q=[]){let J=[],K=q[0],W=0;for(let T=1;T<=Q.length;T++)if(T>=Q.length||q[T]!=K)J.push({mode:K,str:Q.slice(W,T)}),K=q[T],W=T;return J}var w=[(Q,q)=>(Q+q)%2==0,(Q,q)=>q%2==0,(Q,q)=>Q%3==0,(Q,q)=>(Q+q)%3==0,(Q,q)=>(Math.floor(Q/3)+Math.floor(q/2))%2==0,(Q,q)=>Q*q%2+Q*q%3==0,(Q,q)=>(Q*q%2+Q*q%3)%2==0,(Q,q)=>((Q+q)%2+Q*q%3)%2==0];class U{constructor(Q,q){this.w=Q,this.h=q,this.data=new Uint8Array(Math.ceil(Q*q/4))}#Q(Q,q){let J=q*this.w+Q;return[J>>2,(J&3)<<1]}set(Q=0,q=0,J=1){if(Q<0||Q>=this.w||q<0||q>=this.h)return;let[K,W]=this.#Q(Q,q),T=3<<W,Z=(J&1)<<W|1<<W+1;this.data[K]=this.data[K]&~T|Z}get(Q=0,q=0){if(Q<0||Q>=this.w||q<0||q>=this.h)return 0;let[J,K]=this.#Q(Q,q);return this.data[J]>>K&1}used(Q=0,q=0){if(Q<0||Q>=this.w||q<0||q>=this.h)return 0;let[J,K]=this.#Q(Q,q);return this.data[J]>>K+1&1}*tiles(Q=null){let{w:q,h:J,data:K}=this,W=q*J;for(let T=0;T<K.length;T++){let Z=K[T];if(Z===0)continue;let Y=T<<2;for(let $=0;$<4;$++){let F=Y+$;if(F>=W)break;let O=$<<1;if(!(Z&2<<O))continue;let R=Z&1<<O;if(Q==null||!Q==!R)yield[F%q,Math.floor(F/q)]}}}static union(...Q){let q=Math.max(...Q.map((W)=>W.w)),J=Math.max(...Q.map((W)=>W.h)),K=new U(q,J);for(let W of Q)for(let[T,Z]of W.tiles())if(!K.get(T,Z))K.set(T,Z,W.get(T,Z));return K}static erase(Q,...q){let J=new U(Q.w,Q.h);for(let[K,W]of Q.tiles())if(!q.some((T)=>T.used(K,W)))J.set(K,W,Q.get(K,W));return J}static intersect(Q,...q){let J=new U(Q.w,Q.h);for(let[K,W]of Q.tiles())if(q.every((T)=>T.used(K,W)))J.set(K,W,Q.get(K,W));return J}}class E{constructor({version:Q=2,ecl:q=0,mask:J=0,codewords:K=new Uint8Array}={}){this.version=Q,this.ecl=q,this.mask=J,this.codewords=K}get size(){return this.version*4+17}get functional_grid(){let{finder_grid:Q,timing_grid:q,alignment_grid:J,version_grid:K,format_grid:W}=this;return U.union(Q,q,J,K,W)}get finder_grid(){let{size:Q}=this,q=new U(Q,Q);for(let J=0;J<8;J++)for(let K=0;K<8;K++){let W=Math.max(Math.abs(3-J),Math.abs(3-K))!=2&&!(J==7||K==7);q.set(J,K,W),q.set(Q-J-1,K,W),q.set(J,Q-K-1,W)}return q}get timing_grid(){let{size:Q}=this,q=new U(Q,Q);for(let J=8;J<=Q-8;J++){let K=J%2==0;q.set(6,J,K),q.set(J,6,K)}return q}get alignment_positions(){let{version:Q,size:q}=this;if(Q==1)return[];let J=Math.floor(Q/7)+2,K=Q==32?26:Math.ceil((Q*4+4)/(J*2-2))*2,W=[6];for(let T=q-7;W.length<J;T-=K)W.splice(1,0,T);return W}get alignment_grid(){let{version:Q,size:q,alignment_positions:J}=this,K=new U(q,q),W=J.length;for(let T=0;T<W;T++)for(let Z=0;Z<W;Z++)if(!(T==0&&Z==0||T==0&&Z==W-1||T==W-1&&Z==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let F=Math.max(Math.abs($),Math.abs(Y))==1?0:1;K.set(J[T]+$,J[Z]+Y,F)}return K}get format_grid(){let{ecl:Q,mask:q,size:J}=this,K=new U(J,J),W=N[Q].formatBits<<3|q,T=W;for(let Y=0;Y<10;Y++)T=T<<1^(T>>>9)*1335;let Z=(W<<10|T)^21522;for(let Y=0;Y<=5;Y++)K.set(8,Y,Z>>Y);K.set(8,7,Z>>6),K.set(8,8,Z>>7),K.set(7,8,Z>>8);for(let Y=9;Y<15;Y++)K.set(14-Y,8,Z>>Y);for(let Y=0;Y<8;Y++)K.set(this.size-1-Y,8,Z>>Y);for(let Y=8;Y<15;Y++)K.set(8,this.size-15+Y,Z>>Y);return K.set(8,this.size-8,1),K}get version_grid(){let{version:Q,size:q}=this,J=new U(q,q);if(Q<7)return J;let K=Q;for(let T=0;T<12;T++)K=K<<1^(K>>>11)*7973;let W=Q<<12|K;for(let T=0;T<18;T++){let Z=q-11+T%3,Y=Math.floor(T/3);J.set(Z,Y,W>>T),J.set(Y,Z,W>>T)}return J}get data_grid(){let{size:Q,functional_grid:q,codewords:J,mask:K}=this,W=new U(Q,Q),T=0;for(let Z=Q-1;Z>=1;Z-=2){if(Z===6)Z=5;for(let Y=0;Y<Q;Y++)for(let $=0;$<2;$++){let F=Z-$,H=(Z+1&2)===0?Q-1-Y:Y;if(!q.used(F,H)){let I=0;if(T<J.length*8){let L=Math.floor(T/8),M=7-T%8;I=J[L]>>M&1}I^=w[K](F,H),W.set(F,H,I),T++}}}return W}get grid(){let{functional_grid:Q,data_grid:q}=this;return U.union(Q,q)}static create(){}static save(){}static load(){}toString(){return`(QRCode) version:${this.version}, ecl:${this.ecl}, mask:${this.mask}`}[Bun.inspect.custom](){return`(QRCode) version:${this.version}, ecl:${this.ecl}, mask:${this.mask}`}}function K2(Q="",{minVersion:q=1,maxVersion:J=40,minEcl:K=0,maxEcl:W=3,ecl:T=null,version:Z=null,mask:Y=0}={}){if(Z)q=J=Z;if(T)K=W=T;let $=z(Q,{minVersion:q,minEcl:K,maxEcl:W,maxVersion:J});return new E({mask:Y,version:$.version,ecl:$.ecl,codewords:$.codewords})}export{z as optimalStrategy,K2 as createQR,j as constructCodewords,b as allStrategies,E as QRCode,U as Grid};
