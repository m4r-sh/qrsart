var F=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var t=/^[0-9]*$/,o=/^[A-Z0-9 $%*+.\/:-]*$/;var n=new TextEncoder,q={numeric:{modeBits:1,charCost:(f)=>t.test(f)?3.3333333333333335:1/0,numCharCountBits:(f)=>[10,12,14][Math.floor((f+7)/17)],write(f){let h=[];for(let H=0;H<f.length;){let P=Math.min(f.length-H,3);O(parseInt(f.substr(H,P),10),P*3+1,h),H+=P}return h.slice()}},alpha:{modeBits:2,charCost:(f)=>o.test(f)?5.5:1/0,numCharCountBits:(f)=>[9,11,13][Math.floor((f+7)/17)],write(f){let h=[],H;for(H=0;H+2<=f.length;H+=2){let P="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H))*45;P+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H+1)),O(P,11,h)}if(H<f.length)O("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H)),6,h);return h.slice()}},byte:{modeBits:4,charCost:(f)=>g(f)*8,numCharCountBits:(f)=>[8,16,16][Math.floor((f+7)/17)],test:(f)=>!0,write(f){let h=n.encode(f),H=[];for(let P of h)O(P,8,H);return H.slice()}}};function O(f,h,H){while(h>31)O(f>>>h-31,31,H),h-=31;if(f>>>h!==0)throw new RangeError("Value out of range");for(let P=h-1;P>=0;P--)H.push(f>>>P&1)}function g(f){let h=f.codePointAt(0);if(h<0)throw"invalid";else if(h<128)return 1;else if(h<2048)return 2;else if(h<65536)return 3;else if(h<1114112)return 4;else throw"invalid"}function z(f){if(f<1||f>255)throw new RangeError("Degree out of range");let h=[];for(let P=0;P<f-1;P++)h.push(0);h.push(1);let H=1;for(let P=0;P<f;P++){for(let T=0;T<h.length;T++)if(h[T]=D(h[T],H),T+1<h.length)h[T]^=h[T+1];H=D(H,2)}return h}function k(f,h){let H=h.map((P)=>0);for(let P of f){let T=P^H.shift();H.push(0),h.forEach((I,K)=>H[K]^=D(I,T))}return H}function D(f,h){if(f>>>8!=0||h>>>8!=0)throw new RangeError("Byte out of range");let H=0;for(let P=7;P>=0;P--)H=H<<1^(H>>>7)*285,H^=(h>>>P&1)*f;return H}function C(f,{minVersion:h=1,maxVersion:H=40,minEcl:P=0,maxEcl:T=3}={}){let I=h,K=P,B;if(q.numeric.charCost("1")*f.length>R(H,K)*8)throw new Error("Data too long");for(;I<=H;I++){let J=R(I,K)*8;if(I==h||I==10||I==27)B=s(f,I);if(B&&B.cost<=J)break}if(!B||B.cost>R(I,K)*8||I>H)throw new Error("Data too long");for(let J=K+1;J<=T;J++)if(B.cost<=R(I,J)*8)K=J;else break;return{version:I,ecl:K,codewords:c(f,B,I,K),strategy:B}}function*a(f,h,H){let P=R(h,H)*8,T=f.length,I=[{index:0,strategy:new _}];while(I.length){let{index:K,strategy:B}=I.pop();if(K===T){yield B;continue}for(let J of["byte","alpha","numeric"]){let U=q[J].charCost(f[K]);if(U===1/0)continue;let Q=B.lastMode===J?0:4+q[J].numCharCountBits(h),Y=B.cost+Q+U;if(B.lastMode!==J)Y=Math.ceil(Y);let $=(T-1-K)*3.3333333333333335;if(Y>P-$)continue;let A=B.addStep(J,Y);I.push({index:K+1,strategy:A})}}}function s(f,h){let H=f.length,P=Array(H+1).fill().map(()=>({}));P[0][""]=new _;for(let K=1;K<=H;K++)for(let B in P[K-1]){let J=P[K-1][B];for(let U of["numeric","alpha","byte"]){let Q=q[U].charCost(f[K-1]);if(Q===1/0)continue;let Y=J.lastMode===U?0:4+q[U].numCharCountBits(h),$=J.cost+Y+Q;if(J.lastMode!==U)$=Math.ceil($);let A=J.addStep(U,$),M=P[K][U];if(!M||A.cost<M.cost)P[K][U]=A}}let T=P[H],I=null;for(let K in T)if(!I||T[K].cost<I.cost)I=T[K];return I}function c(f,h,H,P){let T=r(f,h),I=[];for(let{mode:W,str:X}of T){O(q[W].modeBits,4,I),O(X.length,q[W].numCharCountBits(H),I);for(let L of q[W].write(X))I.push(L)}let K=R(H,P)*8;O(0,Math.min(4,K-I.length),I),O(0,(8-I.length%8)%8,I);for(let W=236;I.length<K;W^=253)O(W,8,I);let B=[];while(B.length*8<I.length)B.push(0);I.forEach((W,X)=>B[X>>>3]|=W<<7-(X&7));let J=F[P].num_ecc_blocks[H],U=F[P].codewords_per_block[H],Q=Math.floor(y(H)/8),Y=J-Q%J,$=Math.floor(Q/J),A=[],M=z(U);for(let W=0,X=0;W<J;W++){let L=B.slice(X,X+$-U+(W<Y?0:1));X+=L.length;let m=k(L,M);if(W<Y)L.push(0);A.push(L.concat(m))}let N=[];for(let W=0;W<A[0].length;W++)A.forEach((X,L)=>{if(W!=$-U||L>=Y)N.push(X[W])});return new Uint8Array(N)}function y(f){let h=(16*f+128)*f+64;if(f>=2){let H=Math.floor(f/7)+2;h-=(25*H-10)*H-55,h-=f>=7?36:0}return h}function R(f,h){return Math.floor(y(f)/8)-F[h].codewords_per_block[f]*F[h].num_ecc_blocks[f]}function r(f="",h={}){let H=[],P=h.steps,T=P[0],I=0;for(let K=1;K<=f.length;K++)if(K>=f.length||P[K]!=T)H.push({mode:T,str:f.slice(I,K)}),T=P[K],I=K;return H}var d=["byte","numeric","alpha","kanji"],e={byte:0,numeric:1,alpha:2,kanji:3};class _{constructor(f=new Uint8Array(0),h=0,H=0,P=""){this.packed=f,this.length=h,this.cost=H,this.lastMode=P,this._steps=null}addStep(f,h){let{length:H,packed:P}=this,T=Math.floor(H/4),I=(3-H%4)*2,K=P.length+(T<P.length?0:1),B=new Uint8Array(K);return B.set(P),B[T]|=e[f]<<I,new _(B,H+1,h,f)}get steps(){if(this._steps)return this._steps;return Array.from({length:this.length},(f,h)=>{let H=this.packed[Math.floor(h/4)],P=(3-h%4)*2;return d[H>>P&3]})}}var{floor:p}=Math,G=[(f,h)=>(f+h)%2==0,(f,h)=>h%2==0,(f,h)=>f%3==0,(f,h)=>(f+h)%3==0,(f,h)=>(p(f/3)+p(h/2))%2==0,(f,h)=>f*h%2+f*h%3==0,(f,h)=>(f*h%2+f*h%3)%2==0,(f,h)=>((f+h)%2+f*h%3)%2==0];class Z{constructor(f,h){this.w=f,this.h=h;let P=f*h+31>>5;this.valueBits=new Uint32Array(P),this.usedBits=new Uint32Array(P)}#f(f,h){let H=h*this.w+f;return[H>>5,H&31]}set(f=0,h=0,H=1){if(f<0||f>=this.w||h<0||h>=this.h)return;let[P,T]=this.#f(f,h),I=1<<T;if(H&1)this.valueBits[P]|=I;else this.valueBits[P]&=~I;this.usedBits[P]|=I}get(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,P]=this.#f(f,h),T=1<<P;return this.valueBits[H]&T?1:0}used(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,P]=this.#f(f,h),T=1<<P;return this.usedBits[H]&T?1:0}*tiles(f=null){let{w:h,h:H,usedBits:P,valueBits:T}=this,I=h*H,K=P.length;for(let B=0;B<K;B++){let J=P[B];if(J===0)continue;let U=T[B],Q=B<<5;for(let Y=0;Y<32;Y++){let $=Q+Y;if($>=I)break;let A=1<<Y;if(!(J&A))continue;let M=(U&A)!==0;if(f==null||!f==!M)yield[$%h,Math.floor($/h)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let h=Math.max(...f.map((T)=>T.w)),H=Math.max(...f.map((T)=>T.h)),P=new Z(h,H);for(let T of f)for(let[I,K]of T.tiles())if(!P.get(I,K))P.set(I,K,T.get(I,K));return P}static erase(f,...h){let H=new Z(f.w,f.h);for(let[P,T]of f.tiles())if(!h.some((I)=>I.used(P,T)))H.set(P,T,f.get(P,T));return H}static intersect(f,...h){let H=new Z(f.w,f.h);for(let[P,T]of f.tiles())if(h.every((I)=>I.used(P,T)))H.set(P,T,f.get(P,T));return H}static invert(f){let h=new Z(f.w,f.h);for(let[H,P]of f.tiles())h.set(H,P,!f.get(H,P));return h}}var V=BigInt(58);function b(f){let h="",H=BigInt(0);for(let P of f)H=H*BigInt(256)+BigInt(P);while(H>0)h="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"[Number(H%V)]+h,H=H/V;return h}function v(f){let h=new Map("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz".split("").map((T,I)=>[T,BigInt(I)])),H=BigInt(0);for(let T of f){let I=h.get(T);if(I===void 0)throw new Error("Invalid Base58 character");H=H*V+I}let P=[];while(H>0)P.unshift(Number(H%BigInt(256))),H=H/BigInt(256);return new Uint8Array(P)}class E{constructor({version:f=2,ecl:h=0,mask:H=0,codewords:P=new Uint8Array}={}){this.version=f,this.ecl=h,this.mask=H,this.codewords=P}get size(){return this.version*4+17}get functional_grid(){let f=new Z(this.size,this.size);return w(f,this),S(f,this),j(f,this),x(f,this),f}get finder_grid(){let f=new Z(this.size,this.size);return w(f,this),f}get timing_grid(){let f=new Z(this.size,this.size);return S(f,this),f}get alignment_grid(){let f=new Z(this.size,this.size);return j(f,this),f}get format_grid(){let f=new Z(this.size,this.size);return l(f,this),f}get version_grid(){let f=new Z(this.size,this.size);return x(f,this),f}get data_grid(){let f=new Z(this.size,this.size);return u(f,this,this.functional_grid),f}get rawdata_grid(){let f=new Z(this.size,this.size);return u(f,this,this.functional_grid,!0),f}get grid(){let f=new Z(this.size,this.size);return w(f,this),S(f,this),j(f,this),x(f,this),u(f,this),f}toBytes(){return new Uint8Array([this.version&255,(this.ecl&3)<<3|(this.mask&7)<<5,...this.codewords])}toString(){return b(bytes)}static fromBytes(f){return new E({version:f[0],ecl:f[1]>>3&3,mask:f[1]>>5&7,codewords:f.slice(2)})}static fromString(f){return E.fromBytes(v(f))}}function u(f,h,H,P=!1){if(!H)H=f;let{codewords:T,mask:I,size:K}=h;l(f,h);let B=0;for(let J=K-1;J>=1;J-=2){if(J===6)J=5;for(let U=0;U<K;U++)for(let Q=0;Q<2;Q++){let Y=J-Q,A=(J+1&2)===0?K-1-U:U;if(!H.used(Y,A)){let N=0;if(B<T.length*8){let W=Math.floor(B/8),X=7-B%8;N=T[W]>>X&1}if(P!==!0)N^=G[I](Y,A);f.set(Y,A,N),B++}}}}function w(f,{size:h}){for(let H=0;H<8;H++)for(let P=0;P<8;P++){let T=Math.max(Math.abs(3-H),Math.abs(3-P))!=2&&!(H==7||P==7);f.set(H,P,T),f.set(h-H-1,P,T),f.set(H,h-P-1,T)}}function S(f,{size:h}){for(let H=8;H<=h-8;H++){let P=H%2==0;f.set(6,H,P),f.set(H,6,P)}}function j(f,{size:h,version:H}){let P=i(H,h),T=P.length;for(let I=0;I<T;I++)for(let K=0;K<T;K++)if(!(I==0&&K==0||I==0&&K==T-1||I==T-1&&K==0))for(let B=-2;B<=2;B++)for(let J=-2;J<=2;J++){let U=Math.max(Math.abs(J),Math.abs(B))==1?0:1;f.set(P[I]+J,P[K]+B,U)}}function l(f,{ecl:h,mask:H,size:P}){let T=F[h].formatBits<<3|H,I=T;for(let B=0;B<10;B++)I=I<<1^(I>>>9)*1335;let K=(T<<10|I)^21522;for(let B=0;B<=5;B++)f.set(8,B,K>>B);f.set(8,7,K>>6),f.set(8,8,K>>7),f.set(7,8,K>>8);for(let B=9;B<15;B++)f.set(14-B,8,K>>B);for(let B=0;B<8;B++)f.set(P-1-B,8,K>>B);for(let B=8;B<15;B++)f.set(8,P-15+B,K>>B);f.set(8,P-8,1)}function x(f,{version:h,size:H}){if(h<7)return;let P=h;for(let I=0;I<12;I++)P=P<<1^(P>>>11)*7973;let T=h<<12|P;for(let I=0;I<18;I++){let K=H-11+I%3,B=Math.floor(I/3);f.set(K,B,T>>I),f.set(B,K,T>>I)}}function i(f,h){if(f==1)return[];let H=Math.floor(f/7)+2,P=f==32?26:Math.ceil((f*4+4)/(H*2-2))*2,T=[6];for(let I=h-7;T.length<H;I-=P)T.splice(1,0,I);return T}function F2(f="",{minVersion:h=1,maxVersion:H=40,minEcl:P=0,maxEcl:T=3,ecl:I=null,version:K=null,mask:B=0}={}){if(K)h=H=K;if(I)P=T=I;let J=C(f,{minVersion:h,minEcl:P,maxEcl:T,maxVersion:H});return new E({mask:B,version:J.version,ecl:J.ecl,codewords:J.codewords})}export{C as optimalStrategy,F2 as createQR,c as constructCodewords,a as allStrategies,E as QRCode,G as MASK_SHAPES,Z as Grid,F as ECLS};
