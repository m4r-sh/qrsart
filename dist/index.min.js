var Q={low:{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},medium:{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},quartile:{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},high:{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}};function N(O,f,q){if(f<0||f>31||O>>>f!=0)throw new RangeError("Value out of range");for(let F=f-1;F>=0;F--)q.push(O>>>F&1)}var h=/^[0-9]*$/,u=/^[A-Z0-9 $%*+.\/:-]*$/;var v=new TextEncoder;class G{constructor({mode:O,numChars:f,bitData:q,text:F}){this.mode=O,this.numChars=f,this.bitData=q,this.text=F}getData(){return this.bitData.slice()}}var A={numeric:{modeBits:1,numCharCountBits:(O)=>[10,12,14][Math.floor((O+7)/17)],test(O){return h.test(O)},write(O){let f=[];for(let q=0;q<O.length;){const F=Math.min(O.length-q,3);N(parseInt(O.substr(q,F),10),F*3+1,f),q+=F}return new G({mode:"numeric",numChars:O.length,bitData:f,text:O})},charCost:3.33},alpha:{modeBits:2,numCharCountBits:(O)=>[9,11,13][Math.floor((O+7)/17)],test(O){return u.test(O)},write(O){let f=[],q;for(q=0;q+2<=O.length;q+=2){let F="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q))*45;F+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q+1)),N(F,11,f)}if(q<O.length)N("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(O.charAt(q)),6,f);return new G({mode:"alpha",numChars:O.length,bitData:f,text:O})}},byte:{modeBits:4,numCharCountBits:(O)=>[8,16,16][Math.floor((O+7)/17)],write(O){let f=v.encode(O),q=[];for(let F of f)N(F,8,q);return new G({mode:"byte",numChars:f.length,bitData:q,text:O})}}};function z(O){if(O<1||O>255)throw new RangeError("Degree out of range");let f=[];for(let F=0;F<O-1;F++)f.push(0);f.push(1);let q=1;for(let F=0;F<O;F++){for(let T=0;T<f.length;T++)if(f[T]=R(f[T],q),T+1<f.length)f[T]^=f[T+1];q=R(q,2)}return f}function B(O,f){let q=f.map((F)=>0);for(let F of O){const T=F^q.shift();q.push(0),f.forEach((J,W)=>q[W]^=R(J,T))}return q}function R(O,f){if(O>>>8!=0||f>>>8!=0)throw new RangeError("Byte out of range");let q=0;for(let F=7;F>=0;F--)q=q<<1^(q>>>7)*285,q^=(f>>>F&1)*O;return q}function k(O,{minVersion:f=1,maxVersion:q=40,minEcl:F="low"}={}){let T=f,J=F,W,Y;for(;T<=q;T++){const I=E(T,J)*8;if(T==f||T==10||T==27)Y=x(O,T);const K=Y.size;if(K<=I){W=K;break}}if(!W)throw Error("Data too long");let Z=["low","medium","quartile","high"],H=Z.slice(Z.indexOf(F)+1);for(let I of H)if(W<=E(T,I)*8)J=I;else break;return{version:T,ecl:J,bitstring:y(O,Y.steps,T,J)}}function x(O,f=1){const q={byte:(4+A.byte.numCharCountBits(f))*6,alpha:(4+A.alpha.numCharCountBits(f))*6,numeric:(4+A.numeric.numCharCountBits(f))*6};let F=[],T=Array.from(O).map((J,W)=>{let Y={byte:_(O.codePointAt(W))*8*6};if(A.alpha.test(J))Y.alpha=33;if(A.numeric.test(J))Y.numeric=20;return Y});Object.keys(T[0]).forEach((J)=>{F.push({size:q[J]+T[0][J],steps:[J]})});for(let J=1;J<T.length;J++){let W=T[J],Y=[],Z=Infinity;for(let H=0;H<F.length;H++){let I=F[H];Object.keys(W).forEach((K)=>{let D=K=="byte"?Array(W[K]/48).fill(K):[K],X=I.steps[I.steps.length-1]==K?W[K]+I.size:q[K]+Math.floor((I.size+5)/6)*6+W[K];Z=Math.min(Z,X),Y.push({size:X,steps:[...I.steps,...D]})})}F=Y.filter((H)=>H.size<=Z+[14,20,20][Math.floor((f+7)/17)]*6)}return F.sort((J,W)=>J.size-W.size),F=F.map((J)=>({steps:J.steps,size:Math.ceil(J.size/6)})),F[0]}var y=function(O,f,q,F){let T=b(O,f),J=[];for(let $ of T){N(A[$.mode].modeBits,4,J),N($.numChars,A[$.mode].numCharCountBits(q),J);for(let U of $.getData())J.push(U)}const W=E(q,F)*8;N(0,Math.min(4,W-J.length),J),N(0,(8-J.length%8)%8,J);for(let $=236;J.length<W;$^=236^17)N($,8,J);let Y=[];while(Y.length*8<J.length)Y.push(0);J.forEach(($,U)=>Y[U>>>3]|=$<<7-(U&7));const Z=Q[F].num_ecc_blocks[q],H=Q[F].codewords_per_block[q],I=Math.floor(w(q)/8),K=Z-I%Z,D=Math.floor(I/Z);let X=[];const P=z(H);for(let $=0,U=0;$<Z;$++){let M=Y.slice(U,U+D-H+($<K?0:1));U+=M.length;const j=B(M,P);if($<K)M.push(0);X.push(M.concat(j))}let V=[];for(let $=0;$<X[0].length;$++)X.forEach((U,M)=>{if($!=D-H||M>=K)V.push(U[$])});return V.map(($)=>$.toString(2).padStart(8,"0")).join("")},_=function(O=128){if(O<0)throw"invalid";else if(O<128)return 1;else if(O<2048)return 2;else if(O<65536)return 3;else if(O<1114112)return 4;else throw"invalid"},w=function(O){let f=(16*O+128)*O+64;if(O>=2){const q=Math.floor(O/7)+2;f-=(25*q-10)*q-55,f-=O>=7?36:0}return f},E=function(O,f){return Math.floor(w(O)/8)-Q[f].codewords_per_block[O]*Q[f].num_ecc_blocks[O]};function b(O="",f=[]){let q=[],F=f[0],T=0;for(let J=1;J<=O.length;J++)if(J>=O.length||f[J]!=F){let W=O.slice(T,J);q.push(A[F].write(W)),F=f[J],T=J}return q}class L{constructor(O,f){this.arr=new Uint8Array(O*f),this.used=new Uint8Array(O*f),this.w=O,this.h=f}setPixel(O,f,q){let{w:F,h:T}=this;if(O<0||O>=F||f<0||f>=T)return;this.arr[f*F+O]=q&1,this.used[f*F+O]=1}getPixel(O,f){let{w:q,h:F}=this;if(O<0||O>=q||f<0||f>=F)return 0;return this.arr[f*q+O]}usedPixel(O,f){let{w:q,h:F}=this;if(O<0||O>=q||f<0||f>=F)return 0;return this.used[f*q+O]}static combine(...O){let f=Math.max(...O.map((T)=>T.w)),q=Math.max(...O.map((T)=>T.h)),F=new L(f,q);for(let T=0;T<f;T++)for(let J=0;J<q;J++)if(O.some((W)=>W.usedPixel(T,J)))F.setPixel(T,J,O.some((W)=>W.getPixel(T,J)));return F}}var g=[(O,f)=>(O+f)%2==0,(O,f)=>f%2==0,(O,f)=>O%3==0,(O,f)=>(O+f)%3==0,(O,f)=>(Math.floor(O/3)+Math.floor(f/2))%2==0,(O,f)=>O*f%2+O*f%3==0,(O,f)=>(O*f%2+O*f%3)%2==0,(O,f)=>((O+f)%2+O*f%3)%2==0];class S{constructor({version:O=2,ecl:f=0,mask:q=0,bitstring:F="",data:T}={}){this.version=O,this.ecl=f,this.mask=q,this.bitstring=F,this.data=T}get size(){return this.version*4+17}get functional_patterns(){let{finder_patterns:O,timing_patterns:f,alignment_patterns:q,version_pattern:F,format_pattern:T}=this;return L.combine(O,f,q,F,T)}get finder_patterns(){let{size:O}=this,f=new L(O,O);for(let q=0;q<8;q++)for(let F=0;F<8;F++){let T=Math.max(Math.abs(3-q),Math.abs(3-F))!=2&&!(q==7||F==7);f.setPixel(q,F,T),f.setPixel(O-q-1,F,T),f.setPixel(q,O-F-1,T)}return f}get timing_patterns(){let{size:O}=this,f=new L(O,O);for(let q=8;q<=O-8;q++){let F=q%2==0;f.setPixel(6,q,F),f.setPixel(q,6,F)}return f}get alignment_positions(){let{version:O,size:f}=this;if(O==1)return[];const q=Math.floor(O/7)+2,F=O==32?26:Math.ceil((O*4+4)/(q*2-2))*2;let T=[6];for(let J=f-7;T.length<q;J-=F)T.splice(1,0,J);return T}get alignment_patterns(){let{version:O,size:f,alignment_positions:q}=this,F=new L(f,f);const T=q.length;for(let J=0;J<T;J++)for(let W=0;W<T;W++)if(!(J==0&&W==0||J==0&&W==T-1||J==T-1&&W==0))for(let Y=-2;Y<=2;Y++)for(let Z=-2;Z<=2;Z++){let H=Math.max(Math.abs(Z),Math.abs(Y))==1?0:1;F.setPixel(q[J]+Z,q[W]+Y,H)}return F}get format_pattern(){let{ecl:O,mask:f,size:q}=this,F=new L(q,q);const T=Q[O].formatBits<<3|f;let J=T;for(let Y=0;Y<10;Y++)J=J<<1^(J>>>9)*1335;const W=(T<<10|J)^21522;for(let Y=0;Y<=5;Y++)F.setPixel(8,Y,W>>Y);F.setPixel(8,7,W>>6),F.setPixel(8,8,W>>7),F.setPixel(7,8,W>>8);for(let Y=9;Y<15;Y++)F.setPixel(14-Y,8,W>>Y);for(let Y=0;Y<8;Y++)F.setPixel(this.size-1-Y,8,W>>Y);for(let Y=8;Y<15;Y++)F.setPixel(8,this.size-15+Y,W>>Y);return F.setPixel(8,this.size-8,1),F}get version_pattern(){let{version:O,size:f}=this;const q=new L(f,f);if(O<7)return q;let F=O;for(let J=0;J<12;J++)F=F<<1^(F>>>11)*7973;const T=O<<12|F;for(let J=0;J<18;J++){const W=f-11+J%3,Y=Math.floor(J/3);q.setPixel(W,Y,T>>J),q.setPixel(Y,W,T>>J)}return q}get data_pattern(){let{size:O,functional_patterns:f,bitstring:q,mask:F}=this;const T=new L(O,O);let J=0;for(let W=O-1;W>=1;W-=2){if(W==6)W=5;for(let Y=0;Y<O;Y++)for(let Z=0;Z<2;Z++){const H=W-Z,K=(W+1&2)==0?O-1-Y:Y;if(!f.usedPixel(H,K)&&J<q.length){let X=parseInt(q[J]);X^=g[F](H,K),T.setPixel(H,K,X),J++}}}return T}get grid(){let{functional_patterns:O,data_pattern:f}=this;return L.combine(O,f)}}function c(O="",f=""){let q=["T:WPA",`S:${O}`,`P:${f}`];return[[0,1,2],[0,2,1],[1,0,2],[1,2,0],[2,1,0],[2,0,1]].map((F)=>`WIFI:${F.map((T)=>q[T]).join(";")};;`)}function m(O="m4r.sh/tetris",{protocols:f=["http","https"],protocol_caps:q=!0,domain_caps:F=!0,path_caps:T=!1}={}){if(!O.toLowerCase().startsWith("http"))O="http://"+O;let J=new URL(O),{hostname:W,pathname:Y,search:Z,hash:H}=J,I=l({protocols:f,protocol_caps:q}),K=p({domain:W,domain_caps:F}),D=n({path:Y,path_caps:T}),X=[];return I.forEach((P)=>{K.forEach((V)=>{D.forEach(($)=>{X.push(`${P}://${V}${path}${Z}${H}`)})})}),X}var l=function({protocols:O=["HTTP","HTTPS"],protocol_caps:f=!0}={}){let q=[];return O.forEach((F)=>{q.push(...f?C(F):[F])}),q},p=function({domain:O="M4R.SH",domain_caps:f=!0}={}){return f?C(O):[O]},n=function({path:O="/qr/tetris",path_caps:f=!1}={}){return f?C(O):[O]},C=function(O="tEsT"){let f=O.toLowerCase().split(""),q={};for(var F=0,T=1<<O.length;F<T;F++){for(var J=F,W=0;J;J>>=1,W++)f[W]=J&1?f[W].toUpperCase():f[W].toLowerCase();q[f.join("")]=!0}return Object.keys(q)};var Z1=function(O,{minVersion:f=1,maxVersion:q=40,minEcl:F="low",mask:T=0}={}){let{version:J,ecl:W,bitstring:Y}=k(O,{minVersion:f,minEcl:F,maxVersion:q});return new S({data:O,version:J,ecl:W,mask:T,bitstring:Y})};export{c as permuteWIFI,m as permuteURL,k as findVersion,Z1 as createQR,S as QRCode,L as PixelGrid};
