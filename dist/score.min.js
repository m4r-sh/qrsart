class Y{constructor(f,M){this.w=f,this.h=M;let E=f*M,U=Math.ceil(E/32);this.valueBits=new Uint32Array(U),this.usedBits=new Uint32Array(U)}#f(f,M){let E=M*this.w+f;return[E>>5,E&31]}set(f=0,M=0,E=1){if(f<0||f>=this.w||M<0||M>=this.h)return;let[U,w]=this.#f(f,M),O=1<<w;if(E&1)this.valueBits[U]|=O;else this.valueBits[U]&=~O;this.usedBits[U]|=O}get(f=0,M=0){if(f<0||f>=this.w||M<0||M>=this.h)return 0;let[E,U]=this.#f(f,M),w=1<<U;return this.valueBits[E]&w?1:0}used(f=0,M=0){if(f<0||f>=this.w||M<0||M>=this.h)return 0;let[E,U]=this.#f(f,M),w=1<<U;return this.usedBits[E]&w?1:0}*tiles(f=null){let{w:M,h:E,usedBits:U,valueBits:w}=this,O=M*E,J=U.length;for(let Z=0;Z<J;Z++){let K=U[Z];if(K===0)continue;let $=w[Z],_=Z<<5;for(let z=0;z<32;z++){let A=_+z;if(A>=O)break;let q=1<<z;if(!(K&q))continue;let B=($&q)!==0;if(f==null||!f==!B)yield[A%M,Math.floor(A/M)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let M=Math.max(...f.map((w)=>w.w)),E=Math.max(...f.map((w)=>w.h)),U=new Y(M,E);for(let w of f)for(let[O,J]of w.tiles())if(!U.get(O,J))U.set(O,J,w.get(O,J));return U}static erase(f,...M){let E=new Y(f.w,f.h);for(let[U,w]of f.tiles())if(!M.some((O)=>O.used(U,w)))E.set(U,w,f.get(U,w));return E}static intersect(f,...M){let E=new Y(f.w,f.h);for(let[U,w]of f.tiles())if(M.every((O)=>O.used(U,w)))E.set(U,w,f.get(U,w));return E}static invert(f){let M=new Y(f.w,f.h);for(let[E,U]of f.tiles())M.set(E,U,!f.get(E,U));return M}}function F(f,M){let E=[];return Object.keys(M).forEach((U)=>{let w=M[U];for(let[O,J]of f.tiles()){let Z=!0;try{w.points.forEach(([K,$,_=1])=>{Z&=f.used(O+K,J+$)&&f.get(O+K,J+$)==_})}catch(K){Z=!1}if(Z)E.push([U,[O,J]])}}),E.map(([U,[w,O]])=>({shape:M[U],coords:{x:w,y:O}}))}class D{constructor(){this.left=this,this.right=this,this.up=this,this.down=this,this.column=null,this.rowId=null}}class G extends D{constructor(f){super();this.size=0,this.id=f}}function k(f,M,E=[],U={score:0,valid_fits:[]},w=0,O=new Set){if(E.length>U.score)U.score=E.length,U.valid_fits=[...E];if(f.right===f)return U;if(w>=M)return U;let J=null,Z=1/0;for(let K=f.right;K!==f;K=K.right)if(K.size<Z&&K.size>0)Z=K.size,J=K;if(!J||Z===0)throw{done:!0,result:U};H(J),O.add(J.id.join(","));for(let K=J.down;K!==J;K=K.down){E.push(K.rowId);let $=[];for(let _=K.right;_!==K;_=_.right)if(!O.has(_.column.id.join(",")))$.push(_.column),H(_.column),O.add(_.column.id.join(","));k(f,M,E,U,w+1,O),E.pop();while($.length){let _=$.pop();X(_),O.delete(_.id.join(","))}}return X(J),O.delete(J.id.join(",")),U}function I(f,M){try{return k(f,M)}catch(E){if(E.done)return E.result;throw E}}function H(f){f.right.left=f.left,f.left.right=f.right;for(let M=f.down;M!==f;M=M.down)for(let E=M.right;E!==M;E=E.right)E.down.up=E.up,E.up.down=E.down,E.column.size--}function X(f){for(let M=f.up;M!==f;M=M.up)for(let E=M.left;E!==M;E=E.left)E.column.size++,E.down.up=E,E.up.down=E;f.right.left=f,f.left.right=f}function N(f,M){let E=F(f,M),{header:U,columns:w}=b(f,E),O=U.right,J=O.down;for(let A=0;A<10;A++){if(J===O)break;J=J.down}let{score:Z,valid_fits:K}=I(U,w),$=new Y(f.w,f.h),_=[];K.forEach((A)=>{let{shape:q,coords:B}=E[A];q.points.forEach(([Q,V])=>{$.set(B.x+Q,B.y+V,1)}),_.push({shape:q,coords:B})});let z=Y.erase(f,$);return{score:Z,placements:_,used:$,unused:z}}function b(f,M){let E=[];for(let $=0;$<f.h;$++)for(let _=0;_<f.w;_++)if(f.get(_,$))E.push([_,$]);let U=new D,w=E.map(([$,_])=>new G([$,_]));if(w.length>0){for(let $=0;$<w.length;$++){let _=w[$],z=$===0?U:w[$-1],A=$===w.length-1?U:w[$+1];_.left=z,_.right=A,z.right=_,A.left=_}U.right=w[0],U.left=w[w.length-1]}let O=new Map(w.map(($)=>[`${$.id[0]},${$.id[1]}`,$])),J=[];M.forEach(($,_)=>{let{shape:z,coords:A}=$,q=[];z.points.forEach(([B,Q])=>{let V=A.x+B,R=A.y+Q,T=`${V},${R}`;if(O.has(T))q.push(O.get(T))}),J.push({rowIdx:_,nodes:q})}),J.forEach(({rowIdx:$,nodes:_})=>{let z=_.map(()=>new D);_.forEach((A,q)=>{let B=z[q];B.column=A,B.rowId=$,B.down=A.down,B.up=A,A.down.up=B,A.down=B,A.size++,B.right=z[(q+1)%z.length],B.left=z[(q-1+z.length)%z.length]}),z.forEach((A,q)=>{A.right.left=A,A.left.right=A})});let Z=U.right,K=0;while(Z!==U&&K<E.length+1)Z=Z.right,K++;return{header:U,columns:E.length}}function j(f,{diagonal:M=!1,value:E=!0}={}){let U=new Y(f.w,f.h),w=[];function O(J,Z,K){if(!f.used(J,Z))return;if(f.get(J,Z)!=E||U.get(J,Z))return;if(U.set(J,Z,!0),K.push([J,Z]),O(J-1,Z,K),O(J+1,Z,K),O(J,Z-1,K),O(J,Z+1,K),M)O(J-1,Z-1,K),O(J+1,Z-1,K),O(J-1,Z+1,K),O(J+1,Z+1,K)}for(let[J,Z]of f.tiles(E))if(!U.get(J,Z)){let K=[];O(J,Z,K),w.push(K)}return w}function P(f){let M=new Set(f.map(([B,Q])=>`${B},${Q}`)),E=Math.max(...f.map((B)=>B[0]))+1,U=Math.max(...f.map((B)=>B[1]))+1,w=[];for(let B=0;B<=E;B++)for(let Q=0;Q<U;Q++){let V=B>0&&M.has(`${B-1},${Q}`),R=B<E&&M.has(`${B},${Q}`);if(V!==R)w.push([B,Q,"v"])}for(let B=0;B<=U;B++)for(let Q=0;Q<E;Q++){let V=B>0&&M.has(`${Q},${B-1}`),R=B<U&&M.has(`${Q},${B}`);if(V!==R)w.push([Q,B,"h"])}let O=new Map;for(let B of w){let Q,V;if(B[2]==="v")Q=[B[0],B[1]],V=[B[0],B[1]+1];else Q=[B[0],B[1]],V=[B[0]+1,B[1]];let R=`${Q[0]},${Q[1]}`,T=`${V[0]},${V[1]}`;if(!O.has(R))O.set(R,[]);if(!O.has(T))O.set(T,[]);O.get(R).push(B),O.get(T).push(B)}let J=new Set,Z=[];for(let B of w){if(J.has(B))continue;let Q=[],V=B,R;if(V[2]==="v")R=[V[0],V[1]];else R=[V[0],V[1]];if(Q.push([...R]),V[2]==="v")R=[V[0],V[1]+1];else R=[V[0]+1,V[1]];Q.push([...R]),J.add(V);while(!0){let T=`${R[0]},${R[1]}`,L=O.get(T).filter((C)=>C!==V&&!J.has(C));if(L.length===0)break;V=L[0],J.add(V);let W;if(V[2]==="v")if(R[0]===V[0]&&R[1]===V[1])W=[V[0],V[1]+1];else W=[V[0],V[1]];else if(R[0]===V[0]&&R[1]===V[1])W=[V[0]+1,V[1]];else W=[V[0],V[1]];if(Q.push([...W]),R=W,W[0]===Q[0][0]&&W[1]===Q[0][1])break}Z.push(Q)}function K(B){let Q=0;for(let V=0;V<B.length-1;V++)Q+=B[V][0]*B[V+1][1]-B[V+1][0]*B[V][1];return Q/2}function $(B){let Q=1/0,V=1/0,R=-1/0,T=-1/0;for(let[L,W]of B)Q=Math.min(Q,L),V=Math.min(V,W),R=Math.max(R,L),T=Math.max(T,W);return(R-Q)*(T-V)}let _=Z.map((B)=>({path:B,signedArea:K(B),bbArea:$(B)})),z=_.reduce((B,Q,V,R)=>Q.bbArea>R[B].bbArea?V:B,0),A=_[z].path;if(_[z].signedArea<0)A.reverse();let q=_.filter((B,Q)=>Q!==z).map((B)=>B.path);for(let B of q)if(K(B)>0)B.reverse();return[A,...q]}export{k as solveDLX,N as packShapes,P as outlineShape,j as groupTiles,F as findFits,D as DLXNode,G as ColumnHeader};
