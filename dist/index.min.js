var M=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var b=/^[0-9]*$/,l=/^[A-Z0-9 $%*+.\/:-]*$/;var m=new TextEncoder,L={numeric:{modeBits:1,charCost:(f)=>b.test(f)?3.3333333333333335:1/0,numCharCountBits:(f)=>[10,12,14][Math.floor((f+7)/17)],write(f){let h=[];for(let H=0;H<f.length;){let K=Math.min(f.length-H,3);I(parseInt(f.substr(H,K),10),K*3+1,h),H+=K}return h.slice()}},alpha:{modeBits:2,charCost:(f)=>l.test(f)?5.5:1/0,numCharCountBits:(f)=>[9,11,13][Math.floor((f+7)/17)],write(f){let h=[],H;for(H=0;H+2<=f.length;H+=2){let K="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H))*45;K+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H+1)),I(K,11,h)}if(H<f.length)I("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(f.charAt(H)),6,h);return h.slice()}},byte:{modeBits:4,charCost:(f)=>g(f)*8,numCharCountBits:(f)=>[8,16,16][Math.floor((f+7)/17)],test:(f)=>!0,write(f){let h=m.encode(f),H=[];for(let K of h)I(K,8,H);return H.slice()}}};function I(f,h,H){while(h>31)I(f>>>h-31,31,H),h-=31;if(f>>>h!==0)throw new RangeError("Value out of range");for(let K=h-1;K>=0;K--)H.push(f>>>K&1)}function g(f){let h=f.codePointAt(0);if(h<0)throw"invalid";else if(h<128)return 1;else if(h<2048)return 2;else if(h<65536)return 3;else if(h<1114112)return 4;else throw"invalid"}function x(f){if(f<1||f>255)throw new RangeError("Degree out of range");let h=[];for(let K=0;K<f-1;K++)h.push(0);h.push(1);let H=1;for(let K=0;K<f;K++){for(let P=0;P<h.length;P++)if(h[P]=G(h[P],H),P+1<h.length)h[P]^=h[P+1];H=G(H,2)}return h}function z(f,h){let H=h.map((K)=>0);for(let K of f){let P=K^H.shift();H.push(0),h.forEach((J,W)=>H[W]^=G(J,P))}return H}function G(f,h){if(f>>>8!=0||h>>>8!=0)throw new RangeError("Byte out of range");let H=0;for(let K=7;K>=0;K--)H=H<<1^(H>>>7)*285,H^=(h>>>K&1)*f;return H}function k(f,{minVersion:h=1,maxVersion:H=40,minEcl:K=0,maxEcl:P=3}={}){let J=h,W=K,Y;if(L.numeric.charCost("1")*f.length>_(H,W)*8)throw new Error("Data too long");for(;J<=H;J++){let Z=_(J,W)*8;if(J==h||J==10||J==27)Y=o(f,J);if(Y&&Y.cost<=Z)break}if(!Y||Y.cost>_(J,W)*8||J>H)throw new Error("Data too long");for(let Z=W+1;Z<=P;Z++)if(Y.cost<=_(J,Z)*8)W=Z;else break;return{version:J,ecl:W,codewords:C(f,Y,J,W),strategy:Y}}function*t(f,h,H){let K=_(h,H)*8,P=f.length,J=[{index:0,strategy:new D}];while(J.length){let{index:W,strategy:Y}=J.pop();if(W===P){yield Y;continue}for(let Z of["byte","alpha","numeric"]){let $=L[Z].charCost(f[W]);if($===1/0)continue;let X=Y.lastMode===Z?0:4+L[Z].numCharCountBits(h),T=Y.cost+X+$;if(Y.lastMode!==Z)T=Math.ceil(T);let q=(P-1-W)*3.3333333333333335;if(T>K-q)continue;let O=Y.addStep(Z,T);J.push({index:W+1,strategy:O})}}}function o(f,h){let H=f.length,K=Array(H+1).fill().map(()=>({}));K[0][""]=new D;for(let W=1;W<=H;W++)for(let Y in K[W-1]){let Z=K[W-1][Y];for(let $ of["numeric","alpha","byte"]){let X=L[$].charCost(f[W-1]);if(X===1/0)continue;let T=Z.lastMode===$?0:4+L[$].numCharCountBits(h),q=Z.cost+T+X;if(Z.lastMode!==$)q=Math.ceil(q);let O=Z.addStep($,q),N=K[W][$];if(!N||O.cost<N.cost)K[W][$]=O}}let P=K[H],J=null;for(let W in P)if(!J||P[W].cost<J.cost)J=P[W];return J}function C(f,h,H,K){let P=n(f,h),J=[];for(let{mode:Q,str:F}of P){I(L[Q].modeBits,4,J),I(F.length,L[Q].numCharCountBits(H),J);for(let A of L[Q].write(F))J.push(A)}let W=_(H,K)*8;I(0,Math.min(4,W-J.length),J),I(0,(8-J.length%8)%8,J);for(let Q=236;J.length<W;Q^=253)I(Q,8,J);let Y=[];while(Y.length*8<J.length)Y.push(0);J.forEach((Q,F)=>Y[F>>>3]|=Q<<7-(F&7));let Z=M[K].num_ecc_blocks[H],$=M[K].codewords_per_block[H],X=Math.floor(y(H)/8),T=Z-X%Z,q=Math.floor(X/Z),O=[],N=x($);for(let Q=0,F=0;Q<Z;Q++){let A=Y.slice(F,F+q-$+(Q<T?0:1));F+=A.length;let v=z(A,N);if(Q<T)A.push(0);O.push(A.concat(v))}let R=[];for(let Q=0;Q<O[0].length;Q++)O.forEach((F,A)=>{if(Q!=q-$||A>=T)R.push(F[Q])});return new Uint8Array(R)}function y(f){let h=(16*f+128)*f+64;if(f>=2){let H=Math.floor(f/7)+2;h-=(25*H-10)*H-55,h-=f>=7?36:0}return h}function _(f,h){return Math.floor(y(f)/8)-M[h].codewords_per_block[f]*M[h].num_ecc_blocks[f]}function n(f="",h={}){let H=[],K=h.steps,P=K[0],J=0;for(let W=1;W<=f.length;W++)if(W>=f.length||K[W]!=P)H.push({mode:P,str:f.slice(J,W)}),P=K[W],J=W;return H}var a=["byte","numeric","alpha","kanji"],s={byte:0,numeric:1,alpha:2,kanji:3};class D{constructor(f=new Uint8Array(0),h=0,H=0,K=""){this.packed=f,this.length=h,this.cost=H,this.lastMode=K,this._steps=null}addStep(f,h){let{length:H,packed:K}=this,P=Math.floor(H/4),J=(3-H%4)*2,W=K.length+(P<K.length?0:1),Y=new Uint8Array(W);return Y.set(K),Y[P]|=s[f]<<J,new D(Y,H+1,h,f)}get steps(){if(this._steps)return this._steps;return Array.from({length:this.length},(f,h)=>{let H=this.packed[Math.floor(h/4)],K=(3-h%4)*2;return a[H>>K&3]})}}var{floor:c}=Math,V=[(f,h)=>(f+h)%2==0,(f,h)=>h%2==0,(f,h)=>f%3==0,(f,h)=>(f+h)%3==0,(f,h)=>(c(f/3)+c(h/2))%2==0,(f,h)=>f*h%2+f*h%3==0,(f,h)=>(f*h%2+f*h%3)%2==0,(f,h)=>((f+h)%2+f*h%3)%2==0];class U{constructor(f,h){this.w=f,this.h=h;let K=f*h+31>>5;this.valueBits=new Uint32Array(K),this.usedBits=new Uint32Array(K)}#f(f,h){let H=h*this.w+f;return[H>>5,H&31]}set(f=0,h=0,H=1){if(f<0||f>=this.w||h<0||h>=this.h)return;let[K,P]=this.#f(f,h),J=1<<P;if(H&1)this.valueBits[K]|=J;else this.valueBits[K]&=~J;this.usedBits[K]|=J}get(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,K]=this.#f(f,h),P=1<<K;return this.valueBits[H]&P?1:0}used(f=0,h=0){if(f<0||f>=this.w||h<0||h>=this.h)return 0;let[H,K]=this.#f(f,h),P=1<<K;return this.usedBits[H]&P?1:0}*tiles(f=null){let{w:h,h:H,usedBits:K,valueBits:P}=this,J=h*H,W=K.length;for(let Y=0;Y<W;Y++){let Z=K[Y];if(Z===0)continue;let $=P[Y],X=Y<<5;for(let T=0;T<32;T++){let q=X+T;if(q>=J)break;let O=1<<T;if(!(Z&O))continue;let N=($&O)!==0;if(f==null||!f==!N)yield[q%h,Math.floor(q/h)]}}}toValueArray(){return this.valueBits.slice()}static union(...f){let h=Math.max(...f.map((P)=>P.w)),H=Math.max(...f.map((P)=>P.h)),K=new U(h,H);for(let P of f)for(let[J,W]of P.tiles())if(!K.get(J,W))K.set(J,W,P.get(J,W));return K}static erase(f,...h){let H=new U(f.w,f.h);for(let[K,P]of f.tiles())if(!h.some((J)=>J.used(K,P)))H.set(K,P,f.get(K,P));return H}static intersect(f,...h){let H=new U(f.w,f.h);for(let[K,P]of f.tiles())if(h.every((J)=>J.used(K,P)))H.set(K,P,f.get(K,P));return H}static invert(f){let h=new U(f.w,f.h);for(let[H,K]of f.tiles())h.set(H,K,!f.get(H,K));return h}}class B{constructor({version:f=2,ecl:h=0,mask:H=0,codewords:K=new Uint8Array}={}){this.version=f,this.ecl=h,this.mask=H,this.codewords=K}get size(){return this.version*4+17}get functional_grid(){let f=new U(this.size,this.size);return j(f,this),S(f,this),u(f,this),w(f,this),f}get finder_grid(){let f=new U(this.size,this.size);return j(f,this),f}get timing_grid(){let f=new U(this.size,this.size);return S(f,this),f}get alignment_grid(){let f=new U(this.size,this.size);return u(f,this),f}get format_grid(){let f=new U(this.size,this.size);return p(f,this),f}get version_grid(){let f=new U(this.size,this.size);return w(f,this),f}get data_grid(){let f=new U(this.size,this.size);return E(f,this,this.functional_grid),f}get rawdata_grid(){let f=new U(this.size,this.size);return E(f,this,this.functional_grid,!0),f}get grid(){let f=new U(this.size,this.size);return j(f,this),S(f,this),u(f,this),w(f,this),E(f,this),f}toBytes(){return new Uint8Array([this.version&255,(this.ecl&3)<<3|(this.mask&7)<<5,...this.codewords])}toString(){let f=this.toBytes(),h="";return f.forEach((H)=>h+=String.fromCharCode(H)),btoa(h)}static fromBytes(f){return new B({version:f[0],ecl:f[1]>>3&3,mask:f[1]>>5&7,codewords:f.slice(2)})}static fromString(f){return B.fromBytes(Uint8Array.from(atob(f),(h)=>h.charCodeAt(0)))}}function E(f,h,H,K=!1){if(!H)H=f;let{codewords:P,mask:J,size:W}=h;p(f,h);let Y=0;for(let Z=W-1;Z>=1;Z-=2){if(Z===6)Z=5;for(let $=0;$<W;$++)for(let X=0;X<2;X++){let T=Z-X,O=(Z+1&2)===0?W-1-$:$;if(!H.used(T,O)){let R=0;if(Y<P.length*8){let Q=Math.floor(Y/8),F=7-Y%8;R=P[Q]>>F&1}if(K!==!0)R^=V[J](T,O);f.set(T,O,R),Y++}}}}function j(f,{size:h}){for(let H=0;H<8;H++)for(let K=0;K<8;K++){let P=Math.max(Math.abs(3-H),Math.abs(3-K))!=2&&!(H==7||K==7);f.set(H,K,P),f.set(h-H-1,K,P),f.set(H,h-K-1,P)}}function S(f,{size:h}){for(let H=8;H<=h-8;H++){let K=H%2==0;f.set(6,H,K),f.set(H,6,K)}}function u(f,{size:h,version:H}){let K=d(H,h),P=K.length;for(let J=0;J<P;J++)for(let W=0;W<P;W++)if(!(J==0&&W==0||J==0&&W==P-1||J==P-1&&W==0))for(let Y=-2;Y<=2;Y++)for(let Z=-2;Z<=2;Z++){let $=Math.max(Math.abs(Z),Math.abs(Y))==1?0:1;f.set(K[J]+Z,K[W]+Y,$)}}function p(f,{ecl:h,mask:H,size:K}){let P=M[h].formatBits<<3|H,J=P;for(let Y=0;Y<10;Y++)J=J<<1^(J>>>9)*1335;let W=(P<<10|J)^21522;for(let Y=0;Y<=5;Y++)f.set(8,Y,W>>Y);f.set(8,7,W>>6),f.set(8,8,W>>7),f.set(7,8,W>>8);for(let Y=9;Y<15;Y++)f.set(14-Y,8,W>>Y);for(let Y=0;Y<8;Y++)f.set(K-1-Y,8,W>>Y);for(let Y=8;Y<15;Y++)f.set(8,K-15+Y,W>>Y);f.set(8,K-8,1)}function w(f,{version:h,size:H}){if(h<7)return;let K=h;for(let J=0;J<12;J++)K=K<<1^(K>>>11)*7973;let P=h<<12|K;for(let J=0;J<18;J++){let W=H-11+J%3,Y=Math.floor(J/3);f.set(W,Y,P>>J),f.set(Y,W,P>>J)}}function d(f,h){if(f==1)return[];let H=Math.floor(f/7)+2,K=f==32?26:Math.ceil((f*4+4)/(H*2-2))*2,P=[6];for(let J=h-7;P.length<H;J-=K)P.splice(1,0,J);return P}function q2(f="",{minVersion:h=1,maxVersion:H=40,minEcl:K=0,maxEcl:P=3,ecl:J=null,version:W=null,mask:Y=0}={}){if(W)h=H=W;if(J)K=P=J;let Z=k(f,{minVersion:h,minEcl:K,maxEcl:P,maxVersion:H});return new B({mask:Y,version:Z.version,ecl:Z.ecl,codewords:Z.codewords})}export{k as optimalStrategy,q2 as createQR,C as constructCodewords,t as allStrategies,B as QRCode,V as MASK_SHAPES,U as Grid,M as ECLS};
