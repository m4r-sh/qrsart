var D=[{formatBits:1,codewords_per_block:[-1,7,10,15,20,26,18,20,24,30,18,20,24,26,30,22,24,28,30,28,28,28,28,30,30,26,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,1,1,1,2,2,2,2,4,4,4,4,4,6,6,6,6,7,8,8,9,9,10,12,12,12,13,14,15,16,17,18,19,19,20,21,22,24,25]},{formatBits:0,codewords_per_block:[-1,10,16,26,18,24,16,18,22,22,26,30,22,22,24,24,28,28,26,26,26,26,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28,28],num_ecc_blocks:[-1,1,1,1,2,2,4,4,4,5,5,5,8,9,9,10,10,11,13,14,16,17,17,18,20,21,23,25,26,28,29,31,33,35,37,38,40,43,45,47,49]},{formatBits:3,codewords_per_block:[-1,13,22,18,26,18,24,18,22,20,24,28,26,24,20,30,24,28,28,26,30,28,30,30,30,30,28,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,2,4,4,6,6,8,8,8,10,12,16,12,17,16,18,21,20,23,23,25,27,29,34,34,35,38,40,43,45,48,51,53,56,59,62,65,68]},{formatBits:2,codewords_per_block:[-1,17,28,22,16,22,28,26,26,24,28,24,28,22,24,24,30,28,28,26,28,30,24,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30,30],num_ecc_blocks:[-1,1,1,2,4,4,4,5,6,8,8,11,11,16,16,18,16,19,21,25,25,25,34,30,32,35,37,40,42,45,48,51,54,57,60,63,66,70,74,77,81]}];var h=/^[0-9]*$/,C=/^[A-Z0-9 $%*+.\/:-]*$/;var x=new TextEncoder,A={numeric:{modeBits:1,charCost:(q)=>h.test(q)?3.3333333333333335:1/0,numCharCountBits:(q)=>[10,12,14][Math.floor((q+7)/17)],write(q){let J=[];for(let K=0;K<q.length;){let Q=Math.min(q.length-K,3);R(parseInt(q.substr(K,Q),10),Q*3+1,J),K+=Q}return J.slice()}},alpha:{modeBits:2,charCost:(q)=>C.test(q)?5.5:1/0,numCharCountBits:(q)=>[9,11,13][Math.floor((q+7)/17)],write(q){let J=[],K;for(K=0;K+2<=q.length;K+=2){let Q="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(q.charAt(K))*45;Q+="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(q.charAt(K+1)),R(Q,11,J)}if(K<q.length)R("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:".indexOf(q.charAt(K)),6,J);return J.slice()}},byte:{modeBits:4,charCost:(q)=>y(q)*8,numCharCountBits:(q)=>[8,16,16][Math.floor((q+7)/17)],test:(q)=>!0,write(q){let J=x.encode(q),K=[];for(let Q of J)R(Q,8,K);return K.slice()}}};function R(q,J,K){if(J<0||J>31||q>>>J!=0)throw new RangeError("Value out of range");for(let Q=J-1;Q>=0;Q--)K.push(q>>>Q&1)}function y(q){let J=q.codePointAt(0);if(J<0)throw"invalid";else if(J<128)return 1;else if(J<2048)return 2;else if(J<65536)return 3;else if(J<1114112)return 4;else throw"invalid"}function k(q){if(q<1||q>255)throw new RangeError("Degree out of range");let J=[];for(let Q=0;Q<q-1;Q++)J.push(0);J.push(1);let K=1;for(let Q=0;Q<q;Q++){for(let W=0;W<J.length;W++)if(J[W]=G(J[W],K),W+1<J.length)J[W]^=J[W+1];K=G(K,2)}return J}function E(q,J){let K=J.map((Q)=>0);for(let Q of q){let W=Q^K.shift();K.push(0),J.forEach((T,Z)=>K[Z]^=G(T,W))}return K}function G(q,J){if(q>>>8!=0||J>>>8!=0)throw new RangeError("Byte out of range");let K=0;for(let Q=7;Q>=0;Q--)K=K<<1^(K>>>7)*285,K^=(J>>>Q&1)*q;return K}function S(q,{minVersion:J=1,maxVersion:K=40,minEcl:Q=0,maxEcl:W=3}={}){let T=J,Z=Q,Y;if(A.numeric.charCost("1")*q.length>N(K,Z)*8)throw new Error("Data too long");for(;T<=K;T++){let $=N(T,Z)*8;if(T==J||T==10||T==27)Y=u(q,T);if(Y&&Y.cost<=$)break}if(!Y||Y.cost>N(T,Z)*8||T>K)throw new Error("Data too long");for(let $=Z+1;$<=W;$++)if(Y.cost<=N(T,$)*8)Z=$;else break;return{version:T,ecl:Z,bitstring:B(q,Y.steps,T,Z),cost:Y.cost,steps:Y.steps,budget:N(T,Z)*8}}function p(q,J,K){let Q=N(J,K)*8,W=q.length,T=[{cost:0,steps:[],mode:""}];for(let Z=0;Z<W;Z++){let Y=[];for(let $ of T)for(let F of["numeric","alpha","byte"]){let _=A[F].charCost(q[Z]);if(_===1/0)continue;let H=$.mode===F?0:4+A[F].numCharCountBits(J),O=$.cost+H+_;if(O>Q)continue;Y.push({cost:O,steps:[...$.steps,F],mode:F})}T=Y}return T.map(({steps:Z,cost:Y})=>({steps:Z,cost:Y,bitstring:B(q,Z,J,K)}))}function u(q,J){let K=q.length,Q=Array(K+1).fill().map(()=>({}));Q[0]={"":{cost:0,steps:[]}};let W=0;for(let $=1;$<=K;$++)for(let F in Q[$-1]){let _=Q[$-1][F];for(let H of["numeric","alpha","byte"]){let O=A[H].charCost(q[$-1]);if(O===1/0)continue;let I=F===H?0:4+A[H].numCharCountBits(J),V=_.cost+I+O;if(!Q[$][H]||V<Q[$][H].cost)Q[$][H]={cost:V,steps:[..._.steps,H]}}}let T=Q[K],Z=1/0,Y="";for(let $ in T)if(T[$].cost<Z)Z=T[$].cost,Y=$;return T[Y]?{steps:T[Y].steps,cost:T[Y].cost}:null}function B(q,J,K,Q){let W=b(q,J),T=[];for(let{mode:X,str:P}of W){R(A[X].modeBits,4,T),R(P.length,A[X].numCharCountBits(K),T);for(let L of A[X].write(P))T.push(L)}let Z=N(K,Q)*8;R(0,Math.min(4,Z-T.length),T),R(0,(8-T.length%8)%8,T);for(let X=236;T.length<Z;X^=253)R(X,8,T);let Y=[];while(Y.length*8<T.length)Y.push(0);T.forEach((X,P)=>Y[P>>>3]|=X<<7-(P&7));let $=D[Q].num_ecc_blocks[K],F=D[Q].codewords_per_block[K],_=Math.floor(z(K)/8),H=$-_%$,O=Math.floor(_/$),I=[],V=k(F);for(let X=0,P=0;X<$;X++){let L=Y.slice(P,P+O-F+(X<H?0:1));P+=L.length;let w=E(L,V);if(X<H)L.push(0);I.push(L.concat(w))}let f=[];for(let X=0;X<I[0].length;X++)I.forEach((P,L)=>{if(X!=O-F||L>=H)f.push(P[X])});return new Uint8Array(f)}function z(q){let J=(16*q+128)*q+64;if(q>=2){let K=Math.floor(q/7)+2;J-=(25*K-10)*K-55,J-=q>=7?36:0}return J}function N(q,J){return Math.floor(z(q)/8)-D[J].codewords_per_block[q]*D[J].num_ecc_blocks[q]}function b(q="",J=[]){let K=[],Q=J[0],W=0;for(let T=1;T<=q.length;T++)if(T>=q.length||J[T]!=Q)K.push({mode:Q,str:q.slice(W,T)}),Q=J[T],W=T;return K}var j=[(q,J)=>(q+J)%2==0,(q,J)=>J%2==0,(q,J)=>q%3==0,(q,J)=>(q+J)%3==0,(q,J)=>(Math.floor(q/3)+Math.floor(J/2))%2==0,(q,J)=>q*J%2+q*J%3==0,(q,J)=>(q*J%2+q*J%3)%2==0,(q,J)=>((q+J)%2+q*J%3)%2==0];class U{constructor(q,J){this.w=q,this.h=J,this.data=new Uint8Array(Math.ceil(q*J/4))}#q(q,J){let K=J*this.w+q;return[K>>2,(K&3)<<1]}set(q=0,J=0,K=1){if(q<0||q>=this.w||J<0||J>=this.h)return;let[Q,W]=this.#q(q,J),T=3<<W,Z=(K&1)<<W|1<<W+1;this.data[Q]=this.data[Q]&~T|Z}get(q=0,J=0){if(q<0||q>=this.w||J<0||J>=this.h)return 0;let[K,Q]=this.#q(q,J);return this.data[K]>>Q&1}used(q=0,J=0){if(q<0||q>=this.w||J<0||J>=this.h)return 0;let[K,Q]=this.#q(q,J);return this.data[K]>>Q+1&1}*tiles(q=null){let{w:J,h:K,data:Q}=this,W=J*K;for(let T=0;T<Q.length;T++){let Z=Q[T];if(Z===0)continue;let Y=T<<2;for(let $=0;$<4;$++){let F=Y+$;if(F>=W)break;let _=$<<1;if(!(Z&2<<_))continue;let O=Z&1<<_;if(q===!0&&!O)continue;if(q===!1&&O)continue;yield[F%J,Math.floor(F/J)]}}}static union(...q){let J=Math.max(...q.map((W)=>W.w)),K=Math.max(...q.map((W)=>W.h)),Q=new U(J,K);for(let W of q)for(let[T,Z]of W.tiles())if(!Q.get(T,Z))Q.set(T,Z,W.get(T,Z));return Q}static erase(q,...J){let K=new U(q.w,q.h);for(let[Q,W]of q.tiles())if(!J.some((T)=>T.used(Q,W)))K.set(Q,W,q.get(Q,W));return K}static intersect(q,...J){let K=new U(q.w,q.h);for(let[Q,W]of q.tiles())if(J.every((T)=>T.used(Q,W)))K.set(Q,W,q.get(Q,W));return K}}class M{constructor({version:q=2,ecl:J=0,mask:K=0,bitstring:Q=new Uint8Array}={}){this.version=q,this.ecl=J,this.mask=K,this.bitstring=Q}get size(){return this.version*4+17}get functional_grid(){let{finder_grid:q,timing_grid:J,alignment_grid:K,version_grid:Q,format_grid:W}=this;return U.union(q,J,K,Q,W)}get finder_grid(){let{size:q}=this,J=new U(q,q);for(let K=0;K<8;K++)for(let Q=0;Q<8;Q++){let W=Math.max(Math.abs(3-K),Math.abs(3-Q))!=2&&!(K==7||Q==7);J.set(K,Q,W),J.set(q-K-1,Q,W),J.set(K,q-Q-1,W)}return J}get timing_grid(){let{size:q}=this,J=new U(q,q);for(let K=8;K<=q-8;K++){let Q=K%2==0;J.set(6,K,Q),J.set(K,6,Q)}return J}get alignment_positions(){let{version:q,size:J}=this;if(q==1)return[];let K=Math.floor(q/7)+2,Q=q==32?26:Math.ceil((q*4+4)/(K*2-2))*2,W=[6];for(let T=J-7;W.length<K;T-=Q)W.splice(1,0,T);return W}get alignment_grid(){let{version:q,size:J,alignment_positions:K}=this,Q=new U(J,J),W=K.length;for(let T=0;T<W;T++)for(let Z=0;Z<W;Z++)if(!(T==0&&Z==0||T==0&&Z==W-1||T==W-1&&Z==0))for(let Y=-2;Y<=2;Y++)for(let $=-2;$<=2;$++){let F=Math.max(Math.abs($),Math.abs(Y))==1?0:1;Q.set(K[T]+$,K[Z]+Y,F)}return Q}get format_grid(){let{ecl:q,mask:J,size:K}=this,Q=new U(K,K),W=D[q].formatBits<<3|J,T=W;for(let Y=0;Y<10;Y++)T=T<<1^(T>>>9)*1335;let Z=(W<<10|T)^21522;for(let Y=0;Y<=5;Y++)Q.set(8,Y,Z>>Y);Q.set(8,7,Z>>6),Q.set(8,8,Z>>7),Q.set(7,8,Z>>8);for(let Y=9;Y<15;Y++)Q.set(14-Y,8,Z>>Y);for(let Y=0;Y<8;Y++)Q.set(this.size-1-Y,8,Z>>Y);for(let Y=8;Y<15;Y++)Q.set(8,this.size-15+Y,Z>>Y);return Q.set(8,this.size-8,1),Q}get version_grid(){let{version:q,size:J}=this,K=new U(J,J);if(q<7)return K;let Q=q;for(let T=0;T<12;T++)Q=Q<<1^(Q>>>11)*7973;let W=q<<12|Q;for(let T=0;T<18;T++){let Z=J-11+T%3,Y=Math.floor(T/3);K.set(Z,Y,W>>T),K.set(Y,Z,W>>T)}return K}get data_grid(){let{size:q,functional_grid:J,bitstring:K,mask:Q}=this,W=new U(q,q),T=0;for(let Z=q-1;Z>=1;Z-=2){if(Z===6)Z=5;for(let Y=0;Y<q;Y++)for(let $=0;$<2;$++){let F=Z-$,H=(Z+1&2)===0?q-1-Y:Y;if(!J.used(F,H)){let I=0;if(T<K.length*8){let V=Math.floor(T/8),f=7-T%8;I=K[V]>>f&1}I^=j[Q](F,H),W.set(F,H,I),T++}}}return W}get grid(){let{functional_grid:q,data_grid:J}=this;return U.union(q,J)}static save(q){let{version:J,ecl:K,mask:Q,bitstring:W}=q;return new Uint8Array([J&255,(K&3)<<3|(Q&7)<<5,...W])}static load(q){return new M({version:q[0],ecl:q[1]>>3&3,mask:q[1]>>5&7,bitstring:q.slice(2)})}}function K2(q="",{minVersion:J=1,maxVersion:K=40,minEcl:Q=0,maxEcl:W=3,ecl:T=null,version:Z=null,mask:Y=0}={}){if(Z)J=K=Z;if(T)Q=W=T;let $=S(q,{minVersion:J,minEcl:Q,maxEcl:W,maxVersion:K});return new M({mask:Y,...$})}export{S as findOptimalSegmentation,p as findAllSegmentations,K2 as createQR,M as QRCode,U as Grid};
